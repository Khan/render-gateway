{"version":3,"sources":["../../src/shared/create-logger.js"],"names":["devFormatter","level","message","metadata","metadataString","Object","keys","length","JSON","stringify","getFormatters","mode","formatters","winston","format","splat","push","cli","printf","info","combine","getTransport","sink","stream","Writable","write","_write","transports","Stream","Console","lw","LoggingWinston","createLogger","runtimeMode","logLevel","winstonLogger","debug"],"mappings":";;;;;;;AACA;;AACA;;AAEA;;;;;;;;;;;;AAKA;;;;;;;AAOA,MAAMA,YAAY,GAAG,UAAiD;AAAA,MAAhD;AAACC,IAAAA,KAAD;AAAQC,IAAAA;AAAR,GAAgD;AAAA,MAA5BC,QAA4B;;AAClE,QAAMC,cAAc,GAChBD,QAAQ,IAAI,IAAZ,IAAoBE,MAAM,CAACC,IAAP,CAAYH,QAAZ,EAAsBI,MAAtB,KAAiC,CAArD,GACM,EADN,GAEO,IAAGC,IAAI,CAACC,SAAL,CAAeN,QAAf,EAAyB,IAAzB,EAA+B,CAA/B,CAAkC,EAHhD;AAIA,SAAQ,GAAEF,KAAM,KAAIC,OAAQ,GAAEE,cAAe,EAA7C;AACH,CAND;AAQA;;;;;AAGA,MAAMM,aAAa,GAAIC,IAAD,IAA2B;AAC7C,QAAMC,UAAyB,GAAG,CAC9BC,iBAAQC,MAAR,CAAeC,KAAf,EAD8B,CACN;AADM,GAAlC;;AAGA,MAAIJ,IAAI,KAAK,aAAb,EAA4B;AACxBC,IAAAA,UAAU,CAACI,IAAX,CAAgBH,iBAAQC,MAAR,CAAeG,GAAf,CAAmB;AAAChB,MAAAA,KAAK,EAAE;AAAR,KAAnB,CAAhB;AACH;AAED;;;;;;AAIAW,EAAAA,UAAU,CAACI,IAAX,CAAgBH,iBAAQC,MAAR,CAAeI,MAAf,CAAuBC,IAAD,IAAenB,YAAY,CAACmB,IAAD,CAAjD,CAAhB;AACA,SAAON,iBAAQC,MAAR,CAAeM,OAAf,CAAuB,GAAGR,UAA1B,CAAP;AACH,CAdD;AAgBA;;;;;AAGA,MAAMS,YAAY,GAAIV,IAAD,IAA8B;AAC/C,UAAQA,IAAR;AACI;;;;;AAKA;AACA,SAAK,MAAL;AACI;;;;;;;;;AASA,YAAMW,IAAI,GAAG,IAAIC,gBAAOC,QAAX,CAAoB;AAACC,QAAAA,KAAK,EAAE,MAAM,CAAE;AAAhB,OAApB,CAAb,CAVJ,CAWI;;AACAH,MAAAA,IAAI,CAACI,MAAL,GAAcJ,IAAI,CAACG,KAAnB;AACA,aAAO,IAAIZ,iBAAQc,UAAR,CAAmBC,MAAvB,CAA8B;AACjCd,QAAAA,MAAM,EAAEJ,aAAa,CAAC,MAAD,CADY;AAEjCa,QAAAA,MAAM,EAAED;AAFyB,OAA9B,CAAP;;AAKJ,SAAK,aAAL;AACI;;;AAGA,aAAO,IAAIT,iBAAQc,UAAR,CAAmBE,OAAvB,CAA+B;AAClCf,QAAAA,MAAM,EAAEJ,aAAa,CAAC,aAAD;AADa,OAA/B,CAAP;;AAIJ,SAAK,YAAL;AACI;;;;;;;;AAQA,aAAO,IAAIoB,EAAE,CAACC,cAAP,EAAP;AA1CR;AA4CH,CA7CD;AA+CA;;;;;AAGO,MAAMC,YAAY,GAAG,CACxBC,WADwB,EAExBC,QAFwB,KAGf;AACT,QAAMC,aAAa,GAAGtB,iBAAQmB,YAAR,CAAmC;AACrD/B,IAAAA,KAAK,EAAEiC,QAD8C;AAErDP,IAAAA,UAAU,EAAEN,YAAY,CAACY,WAAD;AAF6B,GAAnC,CAAtB;;AAKAE,EAAAA,aAAa,CAACC,KAAd,CACK,yBAAwBF,QAAS,SAAQD,WAAY,GAD1D;AAIA,SAAOE,aAAP;AACH,CAdM","sourcesContent":["// @flow\nimport stream from \"stream\";\nimport winston from \"winston\";\n\nimport * as lw from \"@google-cloud/logging-winston\";\n\nimport type {Transport, NpmLogLevels, Format} from \"winston\";\nimport type {Runtime, Logger, LogLevel, Info} from \"./types.js\";\n\n/**\n * This is how the log message gets formatted.\n *\n * We can expand this to include additional metadata as needed. For example,\n * if we have the profiling API from react-render-server, we could include\n * the duration metadata.\n */\nconst devFormatter = ({level, message, ...metadata}: Info): string => {\n    const metadataString =\n        metadata == null || Object.keys(metadata).length === 0\n            ? \"\"\n            : ` ${JSON.stringify(metadata, null, 4)}`;\n    return `${level}: ${message}${metadataString}`;\n};\n\n/**\n * Build the formatters to give us some nice dev output.\n */\nconst getFormatters = (mode: Runtime): Format => {\n    const formatters: Array<Format> = [\n        winston.format.splat(), // Allows for %s style substitutions\n    ];\n    if (mode === \"development\") {\n        formatters.push(winston.format.cli({level: true}));\n    }\n\n    /**\n     * This must be added after the cli formatter if it is to be used in\n     * the dev output.\n     */\n    formatters.push(winston.format.printf((info: any) => devFormatter(info)));\n    return winston.format.combine(...formatters);\n};\n\n/**\n * Gets the logging transport for the given mode.\n */\nconst getTransport = (mode: Runtime): Transport => {\n    switch (mode) {\n        /**\n         * Our flow types guard against misuse as long as someone is using them.\n         * Let's be defensive and cope with a bad value. In that case, we'll\n         * assume our test mode as it's the most inert.\n         */\n        default:\n        case \"test\":\n            /**\n             * During testing, we just dump logging.\n             * This avoids storing it anywhere and keeps it out of our\n             * test output.\n             * To do this, we use a stream that just writes to nowhere.\n             *\n             * If you want to test logging, you can jest.spy on the logger's\n             * log method, or any other of its more specific logging methods.\n             */\n            const sink = new stream.Writable({write: () => {}});\n            // This is a hack to make our writable stream work $FlowFixMe\n            sink._write = sink.write;\n            return new winston.transports.Stream({\n                format: getFormatters(\"test\"),\n                stream: sink,\n            });\n\n        case \"development\":\n            /**\n             * If we're in dev mode, just use a console transport.\n             */\n            return new winston.transports.Console({\n                format: getFormatters(\"development\"),\n            });\n\n        case \"production\":\n            /**\n             * We must be in production, so we will use the Stackdriver logging\n             * setup.\n             *\n             * If using the Google-provided middleware that adds a log property\n             * to the express request, make sure this transport is passed to\n             * that middleware so that it doesn't add its own.\n             */\n            return new lw.LoggingWinston();\n    }\n};\n\n/**\n * Create a logger for the given runtime mode and log level.\n */\nexport const createLogger = (\n    runtimeMode: Runtime,\n    logLevel: LogLevel,\n): Logger => {\n    const winstonLogger = winston.createLogger<NpmLogLevels>({\n        level: logLevel,\n        transports: getTransport(runtimeMode),\n    });\n\n    winstonLogger.debug(\n        `Created logger (Level=${logLevel} Mode=${runtimeMode})`,\n    );\n\n    return winstonLogger;\n};\n"],"file":"create-logger.js"}