{"version":3,"sources":["../../src/shared/create-logger.js"],"names":["devFormatter","level","message","metadata","metadataString","Object","keys","length","JSON","stringify","getFormatters","mode","formatters","winston","format","splat","push","cli","printf","info","combine","getTransport","logLevel","sink","stream","Writable","write","_write","transports","Stream","Console","lw","LoggingWinston","getDefaultMetadata","instance","pid","instanceID","processID","createLogger","runtimeMode","winstonLogger","kind","Errors","Internal","defaultMeta","debug"],"mappings":"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","sourcesContent":["// @flow\nimport stream from \"stream\";\nimport winston from \"winston\";\nimport * as lw from \"@google-cloud/logging-winston\";\nimport type {Transport, NpmLogLevels, Format} from \"winston\";\n\nimport {Errors} from \"./errors.js\";\nimport {getGatewayInfo} from \"./get-gateway-info.js\";\nimport type {Runtime, Logger, LogLevel, Info} from \"./types.js\";\n\n/**\n * This is how the log message gets formatted.\n *\n * We can expand this to include additional metadata as needed. For example,\n * if we have the profiling API from react-render-server, we could include\n * the duration metadata.\n */\nconst devFormatter = ({level, message, ...metadata}: Info): string => {\n    const metadataString =\n        metadata == null || Object.keys(metadata).length === 0\n            ? \"\"\n            : ` ${JSON.stringify(metadata, null, 4)}`;\n    return `${level}: ${message}${metadataString}`;\n};\n\n/**\n * Build the formatters to give us some nice dev output.\n */\nconst getFormatters = (mode: Runtime): Format => {\n    const formatters: Array<Format> = [\n        winston.format.splat(), // Allows for %s style substitutions\n    ];\n    if (mode === \"development\") {\n        formatters.push(winston.format.cli({level: true}));\n    }\n\n    /**\n     * This must be added after the cli formatter if it is to be used in\n     * the dev output.\n     */\n    formatters.push(winston.format.printf((info: any) => devFormatter(info)));\n    return winston.format.combine(...formatters);\n};\n\n/**\n * Gets the logging transport for the given mode.\n */\nconst getTransport = (mode: Runtime, logLevel: LogLevel): Transport => {\n    switch (mode) {\n        /**\n         * Our flow types guard against misuse as long as someone is using them.\n         * Let's be defensive and cope with a bad value. In that case, we'll\n         * assume our test mode as it's the most inert.\n         */\n        default:\n        case \"test\":\n            /**\n             * During testing, we just dump logging.\n             * This avoids storing it anywhere and keeps it out of our\n             * test output.\n             * To do this, we use a stream that just writes to nowhere.\n             *\n             * If you want to test logging, you can jest.spy on the logger's\n             * log method, or any other of its more specific logging methods.\n             */\n            const sink = new stream.Writable({write: () => {}});\n            /**\n             * $FlowFixMe[cannot-write]\n             * This is a hack to make our writable stream work\n             */\n            sink._write = sink.write;\n            return new winston.transports.Stream({\n                format: getFormatters(\"test\"),\n                stream: sink,\n            });\n\n        case \"development\":\n            /**\n             * If we're in dev mode, just use a console transport.\n             */\n            return new winston.transports.Console({\n                format: getFormatters(\"development\"),\n            });\n\n        case \"production\":\n            /**\n             * We must be in production, so we will use the Stackdriver logging\n             * setup.\n             *\n             * If using the Google-provided middleware that adds a log property\n             * to the express request, make sure this transport is passed to\n             * that middleware so that it doesn't add its own.\n             */\n            return new lw.LoggingWinston({\n                level: logLevel,\n            });\n    }\n};\n\n/**\n * Get default metadata to attach to logs.\n */\nexport const getDefaultMetadata = (): any => {\n    const {instance, pid} = getGatewayInfo();\n    return {\n        instanceID: instance,\n        processID: pid,\n    };\n};\n\n/**\n * Create a logger for the given runtime mode and log level.\n */\nexport const createLogger = (\n    runtimeMode: Runtime,\n    logLevel: LogLevel,\n): Logger => {\n    const winstonLogger = winston.createLogger<NpmLogLevels>({\n        level: logLevel,\n        transports: getTransport(runtimeMode, logLevel),\n        format: winston.format((info) => {\n            // Let's make sure that errors reported without a taxonomic\n            // label get labelled.\n            if (info.level === \"error\" && info.kind == null) {\n                info.kind = Errors.Internal;\n            }\n            return info;\n        })(),\n        defaultMeta: getDefaultMetadata(),\n    });\n\n    winstonLogger.debug(\n        `Created logger (Level=${logLevel} Mode=${runtimeMode})`,\n    );\n\n    return winstonLogger;\n};\n"],"file":"create-logger.js"}