{"version":3,"sources":["../../src/shared/start-gateway.js"],"names":["startGateway","options","app","logger","host","port","name","mode","keepAliveTimeout","process","env","GAE_SERVICE","appWithMiddleware","gateway","listen","err","error","message","address","warn","info","on","close","exit","trickFlow","headersTimeout"],"mappings":";;;;;;;AAEA;;AACA;;AAGA;;;;;;AAMO,eAAeA,YAAf,CAGLC,OAHK,EAGoBC,GAHpB,EAGkE;AACrE,QAAM;AAACC,IAAAA,MAAD;AAASC,IAAAA,IAAT;AAAeC,IAAAA,IAAf;AAAqBC,IAAAA,IAArB;AAA2BC,IAAAA,IAA3B;AAAiCC,IAAAA;AAAjC,MAAqDP,OAA3D;AAEA;;;;;;;AAMA,MAAIQ,OAAO,CAACC,GAAR,CAAYC,WAAZ,IAA2B,IAA/B,EAAqC;AACjCF,IAAAA,OAAO,CAACC,GAAR,CAAYC,WAAZ,GAA0BL,IAA1B;AACH,GAXoE,CAarE;;;AACA,QAAM,wCAAiBC,IAAjB,CAAN,CAdqE,CAgBrE;;AACA,QAAMK,iBAAiB,GAAG,MAAM,oDAC5BV,GAD4B,EAE5BK,IAF4B,EAG5BJ,MAH4B,CAAhC;AAMA;;;;;;;AAMA,QAAMU,OAAO,GAAGD,iBAAiB,CAACE,MAAlB,CAAyBT,IAAzB,EAA+BD,IAA/B,EAAsCW,GAAD,IAAiB;AAClE,QAAIF,OAAO,IAAI,IAAX,IAAmBE,GAAG,IAAI,IAA9B,EAAoC;AAChCZ,MAAAA,MAAM,CAACa,KAAP,CACK,GAAEV,IAAK,iCACHS,GAAG,IAAIA,GAAG,CAACE,OAAZ,IAAwB,eAC3B,EAHL;AAKA;AACH;;AAED,UAAMC,OAAO,GAAGL,OAAO,CAACK,OAAR,EAAhB;;AACA,QAAIA,OAAO,IAAI,IAAX,IAAmB,OAAOA,OAAP,KAAmB,QAA1C,EAAoD;AAChDf,MAAAA,MAAM,CAACgB,IAAP,CAAa,GAAEb,IAAK,mCAAkCY,OAAQ,EAA9D;AACA;AACH;;AAED,UAAMd,IAAI,GAAGc,OAAO,CAACA,OAArB;AACA,UAAMb,IAAI,GAAGa,OAAO,CAACb,IAArB;AACAF,IAAAA,MAAM,CAACiB,IAAP,CAAa,GAAEd,IAAK,sBAAqBF,IAAK,IAAGC,IAAK,EAAtD;AACH,GAnBe,CAAhB;AAqBA;;;;;;;;;;AASAI,EAAAA,OAAO,CAACY,EAAR,CAAW,QAAX,EAAqB,MAAM;AACvB,QAAI,CAACR,OAAL,EAAc;AACV;AACH;;AAEDV,IAAAA,MAAM,CAACiB,IAAP,CAAY,wCAAZ;AAEAP,IAAAA,OAAO,CAACS,KAAR,CAAeP,GAAD,IAAS;AACnB,UAAIA,GAAJ,EAAS;AACLZ,QAAAA,MAAM,CAACa,KAAP,CACK,+BACID,GAAG,IAAIA,GAAG,CAACE,OAAZ,IAAwB,eAC3B,EAHL;AAKAR,QAAAA,OAAO,CAACc,IAAR,CAAa,CAAb;AACH,OAPD,MAOO;AACHd,QAAAA,OAAO,CAACc,IAAR,CAAa,CAAb;AACH;AACJ,KAXD;AAYH,GAnBD;AAqBA;;;;;;;;;;;;;;;;;;;;;;AAqBA,MAAIV,OAAO,IAAI,IAAf,EAAqB;AACjBA,IAAAA,OAAO,CAACL,gBAAR,GAA2BA,gBAAgB,IAAI,KAA/C;AAEA;;;;;;;;AAOA,UAAMgB,SAAc,GAAGX,OAAvB;AACAW,IAAAA,SAAS,CAACC,cAAV,GAA2BZ,OAAO,CAACL,gBAAR,GAA2B,IAAtD;AACH;AACJ","sourcesContent":["// @flow\nimport type {$Application, $Request, $Response} from \"express\";\nimport {useAppEngineMiddleware} from \"./use-app-engine-middleware.js\";\nimport {setupStackdriver} from \"./setup-stackdriver.js\";\nimport type {GatewayOptions, RequestWithLog} from \"./types.js\";\n\n/**\n * Start a gateway application server.\n *\n * This takes a server application definition and attaches middleware before\n * listening on the appropriate port per the passed options.\n */\nexport async function startGateway<\n    TReq: RequestWithLog<$Request>,\n    TRes: $Response,\n>(options: GatewayOptions, app: $Application<TReq, TRes>): Promise<void> {\n    const {logger, host, port, name, mode, keepAliveTimeout} = options;\n\n    /**\n     * Make sure GAE_SERVICE has a value.\n     *\n     * If it isn't set at this point, we're not running in GAE, so we can\n     * set it ourselves.\n     */\n    if (process.env.GAE_SERVICE == null) {\n        process.env.GAE_SERVICE = name;\n    }\n\n    // Set up stackdriver integrations.\n    await setupStackdriver(mode);\n\n    // Add GAE middleware.\n    const appWithMiddleware = await useAppEngineMiddleware<TReq, TRes>(\n        app,\n        mode,\n        logger,\n    );\n\n    /**\n     * Start the gateway listening.\n     *\n     * We need the variable so we can reference it inside the error handling\n     * callback. Feels a bit nasty, but it works.\n     */\n    const gateway = appWithMiddleware.listen(port, host, (err: ?Error) => {\n        if (gateway == null || err != null) {\n            logger.error(\n                `${name} appears not to have started: ${\n                    (err && err.message) || \"Unknown error\"\n                }`,\n            );\n            return;\n        }\n\n        const address = gateway.address();\n        if (address == null || typeof address === \"string\") {\n            logger.warn(`${name} may not have started properly: ${address}`);\n            return;\n        }\n\n        const host = address.address;\n        const port = address.port;\n        logger.info(`${name} running at http://${host}:${port}`);\n    });\n\n    /**\n     * In this server is being run using a process manager, such as PM2, we\n     * may be asked to shutdown gracefully. We do this be listening for the\n     * SIGINT signal and then close the server. This prevents new connections\n     * from coming in and waits until the existing connections complete before\n     * the callback is fired. At which point we can safely shutdown the server.\n     * If we fail to respond then the process manager may try to forcefully\n     * shutdown the server after a timeout.\n     */\n    process.on(\"SIGINT\", () => {\n        if (!gateway) {\n            return;\n        }\n\n        logger.info(\"SIGINT received, shutting down server.\");\n\n        gateway.close((err) => {\n            if (err) {\n                logger.error(\n                    `Error shutting down server: ${\n                        (err && err.message) || \"Unknown Error\"\n                    }`,\n                );\n                process.exit(1);\n            } else {\n                process.exit(0);\n            }\n        });\n    });\n\n    /**\n     * NOTE(somewhatabstract): We have seen many 502 BAD GATEWAY errors in\n     * production Node services. It seems this is because the Node server\n     * is closing a connection before the load balancer is expecting it to.\n     * There is some indication on the Internet [1] that the issue can occur\n     * when Node's (or nginx [2]) keepalive is lower than the load balancer's\n     * keepalive. In addition, the recommended fix is to always have the load\n     * balancer close a connection by ensuring the Node server has a higher\n     * keepalive timeout value than the load balancer.\n     *\n     * Node's default is 5s, but the indication is that the Google load\n     * balancer value is 80s [3]. So, here we default to 90s, but we also\n     * provide a configuration value to change it as needed.\n     *\n     * In addition, it is suggested that the headers timeout should be higher\n     * than the keepalive timeout [1].\n     *\n     * [1] https://shuheikagawa.com/blog/2019/04/25/keep-alive-timeout/\n     * [2] https://blog.percy.io/tuning-nginx-behind-google-cloud-platform-http-s-load-balancer-305982ddb340\n     * [3] https://khanacademy.slack.com/archives/CJSE4TMQX/p1573252787333500\n     */\n    if (gateway != null) {\n        gateway.keepAliveTimeout = keepAliveTimeout || 90000;\n\n        /**\n         * The Flow type for a Node server does not include headersTimeout.\n         * However, if we don't do the following shenanigans, it puts an error\n         * on the appWithMiddleware.listen call above instead of here, and that\n         * just feels wrong. I tried a $FlowIgnore here, but that doesn't work,\n         * it has to be surpressed above in that case.\n         */\n        const trickFlow: any = gateway;\n        trickFlow.headersTimeout = gateway.keepAliveTimeout + 5000;\n    }\n}\n"],"file":"start-gateway.js"}