{"version":3,"sources":["../../src/shared/extract-error.js"],"names":["extractError","error","addPropPrimitives","targetObj","sourceError","props","addedProps","key","value","Object","entries","freeze","response","errorMessage","stack","errorString","toString","message","name"],"mappings":";;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,YAAT,CACHC,KADG,EAEuB;AAC1B;AACA,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B,WAAO;AAACA,MAAAA;AAAD,KAAP;AACH;;AAED,QAAMC,iBAAiB,GAAG,CACtBC,SADsB,EAEtBC,WAFsB,KAGO;AAC7B,UAAMC,KAAK,GAAG,EAAd;AACA,QAAIC,UAAU,GAAG,KAAjB,CAF6B,CAG7B;AACA;AACA;;AACA,SAAK,MAAM,CAACC,GAAD,EAAMC,KAAN,CAAX,IAA2BC,MAAM,CAACC,OAAP,CAAeT,KAAf,CAA3B,EAAkD;AAC9C,cAAQM,GAAR;AACI,aAAK,SAAL;AACA,aAAK,OAAL;AACA,aAAK,MAAL;AACI;AACA;AACA;AACA;AACA;;AAEJ;AACI;AAXR;;AAaA,cAAQ,OAAOC,KAAf;AACI,aAAK,QAAL;AACA,aAAK,SAAL;AACA,aAAK,QAAL;AACIF,UAAAA,UAAU,GAAG,IAAb;AACAD,UAAAA,KAAK,CAACE,GAAD,CAAL,GAAaC,KAAb;AACA;;AAEJ;AACI;AACA;AACA;AAXR;AAaH;;AACD,QAAIF,UAAJ,EAAgB;AACZ;AACA;AACA;AACAH,MAAAA,SAAS,CAACE,KAAV,GAAkBA,KAAlB;AACH;;AACD,WAAOI,MAAM,CAACE,MAAP,CAAcR,SAAd,CAAP;AACH,GA5CD,CAN0B,CAoD1B;AACA;;;AACA,MAAIF,KAAK,CAACW,QAAN,IAAkB,OAAOX,KAAK,CAACW,QAAN,CAAeX,KAAtB,KAAgC,QAAtD,EAAgE;AAC5D,UAAM;AACFW,MAAAA,QAAQ,EAAE;AAACX,QAAAA,KAAK,EAAEY;AAAR;AADR,QAEFZ,KAFJ;AAGA,WAAOC,iBAAiB,CACpB;AACID,MAAAA,KAAK,EAAEY,YADX;AAEIC,MAAAA,KAAK,EAAEb,KAAK,CAACa;AAFjB,KADoB,EAKpBb,KALoB,CAAxB;AAOH,GAjEyB,CAmE1B;;;AACA,MAAIA,KAAK,CAACA,KAAN,IAAeA,KAAK,KAAKA,KAAK,CAACA,KAAnC,EAA0C;AACtC,WAAOD,YAAY,CAAEC,KAAK,CAACA,KAAR,CAAnB;AACH,GAtEyB,CAwE1B;AACA;AACA;;;AACA,QAAMc,WAAW,GAAGd,KAAK,CAACe,QAAN,EAApB;AACA,SAAOd,iBAAiB,CACpB;AACI;AACZ;AACA;AACA;AACA;AACYD,IAAAA,KAAK,EACDc,WAAW,KAAK,iBAAhB,GACMd,KAAK,CAACgB,OAAN,IAAiBhB,KAAK,CAACiB,IAAvB,IAA+B,SADrC,GAEMH,WATd;AAUID,IAAAA,KAAK,EAAEb,KAAK,CAACa;AAVjB,GADoB,EAapBb,KAboB,CAAxB;AAeH","sourcesContent":["// @flow\nimport type {AmbiguousError, SimplifiedError} from \"./types.js\";\n\n/**\n * Extract the root cause error from an ambiguous error.\n *\n * This takes an ambiguous error representation and attempts to turn it into\n * a less ambiguous version.\n *\n * @param {AmbiguousError} error An object or string that represents an error.\n * @returns {SimplifiedError} A simplified error object.\n */\nexport function extractError(\n    error: AmbiguousError,\n): $ReadOnly<SimplifiedError> {\n    // The error is a string, so we just use that.\n    if (typeof error === \"string\") {\n        return {error};\n    }\n\n    const addPropPrimitives = (\n        targetObj: SimplifiedError,\n        sourceError,\n    ): $ReadOnly<SimplifiedError> => {\n        const props = {};\n        let addedProps = false;\n        // This just gets any primitive (number/string/boolean/etc.) values off\n        // the error that might be useful for diagnosing things and coerces them\n        // to strings.\n        for (const [key, value] of Object.entries(error)) {\n            switch (key) {\n                case \"message\":\n                case \"stack\":\n                case \"name\":\n                    // This method will not pick up values behind getters which,\n                    // for normal Error class objects, means this should skip\n                    // things like message and stack, but let's filter them\n                    // out just in case.\n                    continue;\n\n                default:\n                    break;\n            }\n            switch (typeof value) {\n                case \"number\":\n                case \"boolean\":\n                case \"string\":\n                    addedProps = true;\n                    props[key] = value;\n                    break;\n\n                default:\n                    // More complex things are ignored. We're not looking\n                    // to gather all the info.\n                    break;\n            }\n        }\n        if (addedProps) {\n            // It's OK, we want everyone else to see this as not writable,\n            // but know what we're doing.\n            // $FlowIgnore[cannot-write]\n            targetObj.props = props;\n        }\n        return Object.freeze(targetObj);\n    };\n\n    // The error has a response property. This is the style of superagent\n    // failures which sometimes carry the response as a property.\n    if (error.response && typeof error.response.error === \"string\") {\n        const {\n            response: {error: errorMessage},\n        } = error;\n        return addPropPrimitives(\n            {\n                error: errorMessage,\n                stack: error.stack,\n            },\n            error,\n        );\n    }\n\n    // The error references a child error, let's use that.\n    if (error.error && error !== error.error) {\n        return extractError((error.error: any));\n    }\n\n    // It seems it's a regular error.\n    // `toString` should give us a nice error message. If not, we can try\n    // error.message.\n    const errorString = error.toString();\n    return addPropPrimitives(\n        {\n            /**\n             * If the toString just gave us the generic object response,\n             * then try error.message, and if that doesn't work, try the error.name.\n             * If that doesn't exist, fallback to a basic string.\n             */\n            error:\n                errorString === \"[object Object]\"\n                    ? error.message || error.name || \"Unknown\"\n                    : errorString,\n            stack: error.stack,\n        },\n        error,\n    );\n}\n"],"file":"extract-error.js"}