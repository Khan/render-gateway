{"version":3,"sources":["../../src/shared/trace.js"],"names":["trace","logger","name","tracer","Error","silly","profiler","startTimer","beforeMemory","process","memoryUsage","span","createChildSpan","end","info","afterMemory","done","message","level","memoryBefore","memoryAfter","endSpan"],"mappings":";;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;AAmBO,MAAMA,KAAK,GAAG,CACjBC,MADiB,EAEjBC,IAFiB,EAGjBC,MAHiB,KAID;AAChB,MAAI,CAACD,IAAL,EAAW;AACP,UAAM,IAAIE,KAAJ,CAAU,4CAAV,CAAN;AACH;AAED;;;;;;;;;;;;;AAWAH,EAAAA,MAAM,CAACI,KAAP,CAAc,UAASH,IAAK,EAA5B;AAEA;;;;AAGA,QAAMI,QAAQ,GAAGL,MAAM,CAACM,UAAP,EAAjB;AACA,QAAMC,YAAY,GAAGC,OAAO,CAACC,WAAR,EAArB;AAEA;;;;;;;;;AAQA,QAAMC,IAAI,GAAGR,MAAH,aAAGA,MAAH,uBAAGA,MAAM,CAAES,eAAR,CAAwB;AAACV,IAAAA,IAAI,EAAG,UAASA,IAAK;AAAtB,GAAxB,CAAb;AAEA;;;;;AAIA,QAAMW,GAAG,GAAIC,IAAD,IAAmC;AAC3C,UAAMC,WAAW,GAAGN,OAAO,CAACC,WAAR,EAApB;AAEA;;;;;;;AAMAJ,IAAAA,QAAQ,CAACU,IAAT,mBACOF,IADP;AAEIG,MAAAA,OAAO,EAAG,WAAUf,IAAK,EAF7B;AAGIgB,MAAAA,KAAK,EAAE,CAAAJ,IAAI,SAAJ,IAAAA,IAAI,WAAJ,YAAAA,IAAI,CAAEI,KAAN,KAAe,OAH1B;AAIIC,MAAAA,YAAY,EAAEX,YAJlB;AAKIY,MAAAA,WAAW,EAAEL;AALjB;AAQA;;;;;;AAMA;;AACAJ,IAAAA,IAAI,SAAJ,IAAAA,IAAI,WAAJ,YAAAA,IAAI,CAAEU,OAAN;AACH,GAzBD;;AA2BA,SAAO;AACH,QAAInB,IAAJ,GAAW;AACP,aAAOA,IAAP;AACH,KAHE;;AAIHW,IAAAA;AAJG,GAAP;AAMH,CA3EM","sourcesContent":["// @flow\nimport type {Tracer} from \"@google-cloud/trace-agent\";\nimport type {Logger, ITraceSession, TraceSessionInfo} from \"./types.js\";\n\n/**\n * Start tracing an event.\n *\n * This will log the start of a trace and open a trace session, which is\n * returned. Use the returned session to end the trace when the traced event is\n * over. The traced event will be logged and also written to the Google Cloud\n * StackDriver Trace agent.\n *\n * Trace logs include metadata about the trace such as duration and memory\n * usage.\n *\n * @param {Logger} logger A logger to use for documention and timing the\n * traced action.\n * @param {string} name The name of the traced action.\n * @param {Tracer} [tracer] A Google Cloud trace agent tracer which\n * can be used to record the traced action.\n * @returns {ITraceSession} A trace session that the caller should use to\n * indicate when the session is finished.\n */\nexport const trace = (\n    logger: Logger,\n    name: string,\n    tracer?: Tracer,\n): ITraceSession => {\n    if (!name) {\n        throw new Error(\"Must provide a name for the trace session.\");\n    }\n\n    /**\n     * We are going to use the logger's profiling API (provided by winston).\n     * However, we want to mark the start of the trace as it gives us some\n     * debug information which can be valuable when investigating operations.\n     *\n     * Winston only logs when profiling is done and the optional trace agent\n     * tracer will only show the span if it is ended.\n     *\n     * Since this is noise in most situations, we will log this at the lowest\n     * level of silly.\n     */\n    logger.silly(`TRACE: ${name}`);\n\n    /**\n     * Now we start the profiling timer.\n     */\n    const profiler = logger.startTimer();\n    const beforeMemory = process.memoryUsage();\n\n    /**\n     * Next, if we were given a tracer, we start a trace section for this so\n     * trace session so that it will appear in Stackdriver Trace.\n     *\n     * We annotate the span with \"TRACE:\" so that it is clear in the trace\n     * which spans were created by this API and which were inserted by other\n     * means.\n     */\n    const span = tracer?.createChildSpan({name: `TRACE: ${name}`});\n\n    /**\n     * This is the function that we will return to our caller.\n     * It can then be used to end and record the trace session.\n     */\n    const end = (info?: TraceSessionInfo): void => {\n        const afterMemory = process.memoryUsage();\n\n        /**\n         * Let's mark our profile as done.\n         *\n         * We include the session info object, but make sure to set the level\n         * and message ourselves.\n         */\n        profiler.done({\n            ...info,\n            message: `TRACED: ${name}`,\n            level: info?.level || \"debug\",\n            memoryBefore: beforeMemory,\n            memoryAfter: afterMemory,\n        });\n\n        /**\n         * If we started a tracer span, let's end it.\n         *\n         * We disable this lint rule as the linter does not appear to\n         * understand the optional chaining.\n         */\n        // eslint-disable-next-line flowtype/no-unused-expressions\n        span?.endSpan();\n    };\n\n    return {\n        get name() {\n            return name;\n        },\n        end,\n    };\n};\n"],"file":"trace.js"}