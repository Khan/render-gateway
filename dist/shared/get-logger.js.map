{"version":3,"sources":["../../src/shared/get-logger.js"],"names":["getLogger","request","rootLogger"],"mappings":";;;;;;;AAEA;;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMA,SAAS,GAClBC,OADqB,IAEZ;AACT,QAAMC,UAAU,GAAG,gCAAnB;AACA,SAAO,wCAAiBA,UAAjB,EAA6BD,OAA7B,CAAP;AACH,CALM","sourcesContent":["// @flow\nimport type {$Request} from \"express\";\nimport {getRequestLogger} from \"./get-request-logger.js\";\nimport {getRootLogger} from \"./root-logger.js\";\nimport type {Logger, RequestWithLog} from \"./types.js\";\n\n/**\n * Get the logger to use in the current context.\n *\n * When given a request, if that request has a log property, then that logger\n * is returned, otherwise the top-level logger instance is returned. This\n * provides a convenience so that the calling code does not need to know the\n * source of the logger.\n *\n * There is no need for things to knowingly request the top-level logger\n * as things that are logging should not care. However, in a case where there\n * is no request to use for context, it is equivalent to explicitly requesting\n * the top-level logger.\n */\nexport const getLogger = <TReq: RequestWithLog<$Request>>(\n    request?: TReq,\n): Logger => {\n    const rootLogger = getRootLogger();\n    return getRequestLogger(rootLogger, request);\n};\n"],"file":"get-logger.js"}