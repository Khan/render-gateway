{"version":3,"file":"get-agent-for-url.js","names":["getAgentForURL","url","agentOptions","keepAlive","protocol","http","require","Agent","https","KAError","Errors","InvalidInput"],"sources":["../../src/shared/get-agent-for-url.js"],"sourcesContent":["// @flow\nimport type {URL} from \"url\";\nimport type {Agent as HttpAgent} from \"http\";\nimport type {Agent as HttpsAgent} from \"https\";\nimport {Errors} from \"./errors.js\";\nimport KAError from \"./ka-error.js\";\n\n/**\n * When making requests from one Node service to other services, we have seen\n * some long delays establishing TCP connections to the load balancer of those\n * backends. To try and workaround the problem, we ensure the keepAlive option\n * of the agent is set. It is hoped that this will re-use a recently released\n * socket instead of creating a new one on each request.\n *\n * If a socket is not available, the agent will automatically create a new one.\n * If increased load on the Node service results in similar connection delays,\n * we may consider setting maxSockets to instruct the agent to limit the\n * number of sockets created per destination host.\n *\n * NOTE: agentkeepalive and http/2 have been tried with superagent to see if\n * we could utilize those approaches, which provide more persistent connections.\n * However, App Engine/load balancer appear to interrupt the creation of these\n * persistent connections. It could be that the relevant ports need to be\n * listened on for that to work correctly, so further investigation into those\n * options might bear some fruit.\n *\n * For now, we do this.\n */\n\n/**\n * Get a new agent to use for a given URL.\n *\n * For keep-alive behavior to work, the agent must be shared across requests\n * but this is left for the calling code to manage. We do this because once the\n * agent isn't needed (such as at the end of a request), we want to destroy it.\n * Otherwise, it can hang around keeping sockets open which can lead to\n * retaining large chunks of memory and creating memory leaks.\n */\nexport const getAgentForURL = (url: URL): HttpAgent | HttpsAgent => {\n    const agentOptions = {keepAlive: true};\n    switch (url.protocol) {\n        case \"http:\":\n            const http = require(\"http\");\n            return new http.Agent(agentOptions);\n\n        case \"https:\":\n            const https = require(\"https\");\n            return new https.Agent(agentOptions);\n\n        default:\n            throw new KAError(\n                `Unsupported protocol: ${url.protocol}`,\n                Errors.InvalidInput,\n            );\n    }\n};\n"],"mappings":";;;;;;AAIA;AACA;AAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMA,cAAc,GAAIC,GAAQ,IAA6B;EAChE,MAAMC,YAAY,GAAG;IAACC,SAAS,EAAE;EAAI,CAAC;EACtC,QAAQF,GAAG,CAACG,QAAQ;IAChB,KAAK,OAAO;MACR,MAAMC,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;MAC5B,OAAO,IAAID,IAAI,CAACE,KAAK,CAACL,YAAY,CAAC;IAEvC,KAAK,QAAQ;MACT,MAAMM,KAAK,GAAGF,OAAO,CAAC,OAAO,CAAC;MAC9B,OAAO,IAAIE,KAAK,CAACD,KAAK,CAACL,YAAY,CAAC;IAExC;MACI,MAAM,IAAIO,gBAAO,CACZ,yBAAwBR,GAAG,CAACG,QAAS,EAAC,EACvCM,cAAM,CAACC,YAAY,CACtB;EAAC;AAEd,CAAC;AAAC"}