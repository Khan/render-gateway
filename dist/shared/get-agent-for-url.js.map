{"version":3,"file":"get-agent-for-url.js","names":["_errors","require","_kaError","_interopRequireDefault","obj","__esModule","default","getAgentForURL","url","agentOptions","keepAlive","protocol","http","Agent","https","KAError","Errors","InvalidInput","exports"],"sources":["../../src/shared/get-agent-for-url.js"],"sourcesContent":["// @flow\nimport type {URL} from \"url\";\nimport type {Agent as HttpAgent} from \"http\";\nimport type {Agent as HttpsAgent} from \"https\";\nimport {Errors} from \"./errors.js\";\nimport KAError from \"./ka-error.js\";\n\n/**\n * When making requests from one Node service to other services, we have seen\n * some long delays establishing TCP connections to the load balancer of those\n * backends. To try and workaround the problem, we ensure the keepAlive option\n * of the agent is set. It is hoped that this will re-use a recently released\n * socket instead of creating a new one on each request.\n *\n * If a socket is not available, the agent will automatically create a new one.\n * If increased load on the Node service results in similar connection delays,\n * we may consider setting maxSockets to instruct the agent to limit the\n * number of sockets created per destination host.\n *\n * NOTE: agentkeepalive and http/2 have been tried with superagent to see if\n * we could utilize those approaches, which provide more persistent connections.\n * However, App Engine/load balancer appear to interrupt the creation of these\n * persistent connections. It could be that the relevant ports need to be\n * listened on for that to work correctly, so further investigation into those\n * options might bear some fruit.\n *\n * For now, we do this.\n */\n\n/**\n * Get a new agent to use for a given URL.\n *\n * For keep-alive behavior to work, the agent must be shared across requests\n * but this is left for the calling code to manage. We do this because once the\n * agent isn't needed (such as at the end of a request), we want to destroy it.\n * Otherwise, it can hang around keeping sockets open which can lead to\n * retaining large chunks of memory and creating memory leaks.\n */\nexport const getAgentForURL = (url: URL): HttpAgent | HttpsAgent => {\n    const agentOptions = {keepAlive: true};\n    switch (url.protocol) {\n        case \"http:\":\n            const http = require(\"http\");\n            return new http.Agent(agentOptions);\n\n        case \"https:\":\n            const https = require(\"https\");\n            return new https.Agent(agentOptions);\n\n        default:\n            throw new KAError(\n                `Unsupported protocol: ${url.protocol}`,\n                Errors.InvalidInput,\n            );\n    }\n};\n"],"mappings":";;;;;;AAIA,IAAAA,OAAA,GAAAC,OAAA;AACA,IAAAC,QAAA,GAAAC,sBAAA,CAAAF,OAAA;AAAoC,SAAAE,uBAAAC,GAAA,WAAAA,GAAA,IAAAA,GAAA,CAAAC,UAAA,GAAAD,GAAA,KAAAE,OAAA,EAAAF,GAAA;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMG,cAAc,GAAIC,GAAQ,IAA6B;EAChE,MAAMC,YAAY,GAAG;IAACC,SAAS,EAAE;EAAI,CAAC;EACtC,QAAQF,GAAG,CAACG,QAAQ;IAChB,KAAK,OAAO;MACR,MAAMC,IAAI,GAAGX,OAAO,CAAC,MAAM,CAAC;MAC5B,OAAO,IAAIW,IAAI,CAACC,KAAK,CAACJ,YAAY,CAAC;IAEvC,KAAK,QAAQ;MACT,MAAMK,KAAK,GAAGb,OAAO,CAAC,OAAO,CAAC;MAC9B,OAAO,IAAIa,KAAK,CAACD,KAAK,CAACJ,YAAY,CAAC;IAExC;MACI,MAAM,IAAIM,gBAAO,CACZ,yBAAwBP,GAAG,CAACG,QAAS,EAAC,EACvCK,cAAM,CAACC,YAAY,CACtB;EAAC;AAEd,CAAC;AAACC,OAAA,CAAAX,cAAA,GAAAA,cAAA"}