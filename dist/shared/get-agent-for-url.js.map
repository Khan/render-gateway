{"version":3,"sources":["../../src/shared/get-agent-for-url.js"],"names":["getAgentForURL","url","agentOptions","keepAlive","protocol","http","require","Agent","https","KAError","Errors","InvalidInput"],"mappings":";;;;;;;AAIA;;AACA;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMA,cAAc,GAAIC,GAAD,IAAsC;AAChE,QAAMC,YAAY,GAAG;AAACC,IAAAA,SAAS,EAAE;AAAZ,GAArB;;AACA,UAAQF,GAAG,CAACG,QAAZ;AACI,SAAK,OAAL;AACI,YAAMC,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,aAAO,IAAID,IAAI,CAACE,KAAT,CAAeL,YAAf,CAAP;;AAEJ,SAAK,QAAL;AACI,YAAMM,KAAK,GAAGF,OAAO,CAAC,OAAD,CAArB;;AACA,aAAO,IAAIE,KAAK,CAACD,KAAV,CAAgBL,YAAhB,CAAP;;AAEJ;AACI,YAAM,IAAIO,gBAAJ,CACD,yBAAwBR,GAAG,CAACG,QAAS,EADpC,EAEFM,eAAOC,YAFL,CAAN;AAVR;AAeH,CAjBM","sourcesContent":["// @flow\nimport type {URL} from \"url\";\nimport type {Agent as HttpAgent} from \"http\";\nimport type {Agent as HttpsAgent} from \"https\";\nimport {Errors} from \"./errors.js\";\nimport KAError from \"./ka-error.js\";\n\n/**\n * When making requests from one Node service to other services, we have seen\n * some long delays establishing TCP connections to the load balancer of those\n * backends. To try and workaround the problem, we ensure the keepAlive option\n * of the agent is set. It is hoped that this will re-use a recently released\n * socket instead of creating a new one on each request.\n *\n * If a socket is not available, the agent will automatically create a new one.\n * If increased load on the Node service results in similar connection delays,\n * we may consider setting maxSockets to instruct the agent to limit the\n * number of sockets created per destination host.\n *\n * NOTE: agentkeepalive and http/2 have been tried with superagent to see if\n * we could utilize those approaches, which provide more persistent connections.\n * However, App Engine/load balancer appear to interrupt the creation of these\n * persistent connections. It could be that the relevant ports need to be\n * listened on for that to work correctly, so further investigation into those\n * options might bear some fruit.\n *\n * For now, we do this.\n */\n\n/**\n * Get a new agent to use for a given URL.\n *\n * For keep-alive behavior to work, the agent must be shared across requests\n * but this is left for the calling code to manage. We do this because once the\n * agent isn't needed (such as at the end of a request), we want to destroy it.\n * Otherwise, it can hang around keeping sockets open which can lead to\n * retaining large chunks of memory and creating memory leaks.\n */\nexport const getAgentForURL = (url: URL): HttpAgent | HttpsAgent => {\n    const agentOptions = {keepAlive: true};\n    switch (url.protocol) {\n        case \"http:\":\n            const http = require(\"http\");\n            return new http.Agent(agentOptions);\n\n        case \"https:\":\n            const https = require(\"https\");\n            return new https.Agent(agentOptions);\n\n        default:\n            throw new KAError(\n                `Unsupported protocol: ${url.protocol}`,\n                Errors.InvalidInput,\n            );\n    }\n};\n"],"file":"get-agent-for-url.js"}