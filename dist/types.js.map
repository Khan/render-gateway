{"version":3,"file":"types.js","names":[],"sources":["../src/types.js"],"sourcesContent":["// @flow\nimport type {Agent as HttpAgent} from \"http\";\nimport type {Agent as HttpsAgent} from \"https\";\nimport type {$Response} from \"express\";\nimport type {CallbackHandler, Plugin} from \"superagent\";\nimport type {SecretString} from \"@khanacademy/wonder-stuff-core\";\nimport type {\n    Logger,\n    ServerOptions,\n    ITraceSession,\n} from \"@khanacademy/wonder-stuff-server\";\n\n/**\n * A thing that can be closed.\n */\nexport interface ICloseable {\n    /**\n     * Close the closeable.\n     */\n    +close?: () => ?Promise<void>;\n}\n\nexport type ResponseSource = \"unknown\" | \"cache\" | \"new request\";\n\n/**\n * Represents an error and associated stack.\n */\nexport type SimplifiedError = {\n    /**\n     * A string representing the error that occurred.\n     * In some circumstances, this will match the stack property.\n     */\n    +error: ?string,\n\n    /**\n     * The error's stack, if it has one.\n     */\n    +stack?: string,\n\n    /**\n     * Additional properties that the source error had.\n     */\n    +props?: {\n        +[key: string]: string | number | boolean,\n        ...\n    },\n};\n\n/**\n * Represents an error when we don't really know how it is structured.\n *\n * Use extractError to turn this into a SimplifiedError representation.\n */\nexport type AmbiguousError =\n    | SimplifiedError\n    | string\n    | {\n          error?: AmbiguousError,\n          response?: {\n              error?: string,\n          },\n          stack?: string,\n          message?: string,\n          name?: string,\n          ...\n      }\n    | Error;\n\n/**\n * Options for configuring incoming request authentication.\n */\nexport type AuthenticationOptions = {\n    /**\n     * The key of the secret that must be matched.\n     *\n     * This secret is loaded from the secrets.json.enc file that the service\n     * must provide.\n     */\n    +secretKey: string,\n\n    /**\n     * The key of the secret that we are deprecating.\n     *\n     * This secret is loaded from the secrets.json.enc file that the service\n     * must provide. It is there so that we can rotate out a deprecated secret\n     * without impairing functionality.\n     */\n    +deprecatedSecretKey?: string,\n\n    /**\n     * The name of the header to be matched.\n     *\n     * This is a header in the request, the value of which will be matched\n     * against the secret identified by `secretKey`.\n     */\n    +headerName: string,\n\n    /**\n     * The Google Cloud KMS cryptography key path.\n     *\n     * This is the KMS path used to decode the secrets.json.enc file so that\n     * the secret identifed by `secretKey` can be obtained.\n     */\n    +cryptoKeyPath: string,\n};\n\n/**\n * A promise that has an abort() method.\n */\nexport interface AbortablePromise<T> extends Promise<T> {\n    abort: () => void;\n    aborted: boolean;\n}\n\nexport interface TraceCallback {\n    /**\n     * Begin a trace session.\n     *\n     * @param {string} action A terse name of the traced action.\n     * @param {string} message A message to be logged for this trace.\n     * @returns {ITraceSession} A trace session that the caller should use to\n     * indicate when the session is finished.\n     */\n    (action: string, message: string): ITraceSession;\n}\n\n/**\n * The result of an error handling operation.\n */\nexport type ErrorResult = {\n    /**\n     * The body of the response that is to be sent back from the gateway.\n     */\n    +body: string,\n\n    /**\n     * Headers to be attached to the response.\n     */\n    +headers: ResponseHeaders,\n};\n\nexport interface CustomErrorHandlerFn {\n    /**\n     * Provide a response body for the given error.\n     *\n     * @param {string} url The URL that we were trying to render.\n     * @param {SimplifiedError} error The error to be handled.\n     * @returns {?ErrorResult|?Promise<ErrorResult>} An error result or the\n     * promise of an error result to be returned for the error,\n     * or, `null` if the original error is to be given.\n     */\n    (\n        url: string,\n        headers: any,\n        error: SimplifiedError,\n    ): ?ErrorResult | ?Promise<ErrorResult>;\n}\n\n/**\n * Header names and their values for attaching to a response from the gateway.\n */\nexport type ResponseHeaders = {\n    [name: string]: string,\n    ...\n};\n\n/**\n * The result of a render operation.\n */\nexport type RenderResult = {\n    /**\n     * The body of the response that is to be sent back from the gateway.\n     */\n    +body: string,\n\n    /**\n     * The HTTP status code.\n     */\n    +status: number,\n\n    /**\n     * Headers to be attached to the response.\n     */\n    +headers: ResponseHeaders,\n};\n\n/**\n * The API exposed for use during a render operation.\n */\nexport type RenderAPI = {\n    /**\n     * A dict of headers that've come from the client.\n     *\n     * Access of these headers should be tracked and a Vary header should be\n     * set based on their access (even if they don't exist).\n     */\n    headers: {[header: string]: string, ...},\n\n    /**\n     * Callback to start a trace session for tracing an operation.\n     */\n    +trace: TraceCallback,\n\n    /**\n     * A logger to use for logging during the render operation.\n     */\n    +logger: Logger,\n};\n\n/**\n * Options for configuring the gateway.\n */\nexport type RenderGatewayOptions = {\n    /**\n     * The name of the gateway service.\n     */\n    +name: string,\n\n    /**\n     * The port on which the gateway service will listen.\n     */\n    +port: number,\n\n    /**\n     * The hostname to which the gateway service should bind.\n     */\n    +host: string,\n\n    /**\n     * Optional value in milliseconds for keepalive timeout of the server.\n     * For running in Google Cloud, this should be higher than the load\n     * balancer's own keepalive timeout value, which at time of writing was\n     * indicated to be 80000ms [1].\n     *\n     * [1] https://khanacademy.slack.com/archives/CJSE4TMQX/p1573252787333500\n     *\n     * Defaults to 90000.\n     */\n    +keepAliveTimeout?: number,\n\n    /**\n     * Options to indicate how to authenticate incoming render requests.\n     */\n    +authentication?: AuthenticationOptions,\n\n    /**\n     * The environment that will handle rendering.\n     */\n    +renderEnvironment: IRenderEnvironment,\n\n    /**\n     * Handler that will be invoked if a render request causes an exception.\n     *\n     * This provides the running server with an opportunity to override the\n     * default uncaught error response and provide a more friendly message.\n     */\n    +uncaughtRenderErrorHandler?: CustomErrorHandlerFn,\n\n    /**\n     * A string that will be used to build an error response for a failed\n     * render if all other error handling options fail.\n     *\n     * If the sequence ${error} appears in the string, it will be replaced\n     * with the JSONified error information. If it does not appear, the\n     * JSONified error information will be omitted (useful if you don't want\n     * to include that for users).\n     */\n    +defaultRenderErrorResponse?: string,\n\n    /**\n     * Specify which cloud facilities we want.\n     */\n    +cloudOptions?: ServerOptions[\"integrations\"],\n};\n\n/**\n * The request type that we use with express.\n *\n * STOPSHIP: Had to do this because in Flow, $Request is not compatible with\n * the flow type exported by Wonder Stuff. NO point in fixing as this will\n * go away with the migration.\n */\nexport type Request = any; //RequestWithLog<$Request>;\n\n/**\n * The response type that we use with express.\n */\nexport type Response = $Response;\n\n/**\n * Timeouts for a request.\n */\nexport type Timeouts = {\n    /**\n     * The total time the request is allowed to take before it times out.\n     */\n    deadline?: number,\n\n    /**\n     * The time to wait for a response before a request times out.\n     */\n    response?: number,\n};\n\n/**\n * Options to configure a request.\n */\nexport type RequestOptions = {\n    /**\n     * Time to wait in milliseconds before a request times out.\n     */\n    +timeout: number | Timeouts,\n\n    /**\n     * The number of times a request is retried if it fails from a transient\n     * error. This is in addition to the initial request. For example, if this\n     * were set to 3, then there could be a total of 4 requests.\n     * Note that for all GET requests made during server-side rendering,\n     * it is assumed they will be idempotent.\n     */\n    +retries: number,\n\n    /**\n     * The agent to be used for the request.\n     */\n    +agent?: HttpAgent | HttpsAgent,\n\n    /**\n     * The superagent-cache-plugin instance that will be used.\n     */\n    +cachePlugin?: Plugin,\n\n    /**\n     * A callback to calculate when the cached response for a given URL should\n     * expire. If this method is omitted, the cache provider's default\n     * expiration will be used. The result is given to superagent-cache-plugin\n     * and works according to its documentation.\n     *\n     * https://github.com/jpodwys/superagent-cache-plugin/tree/02e41c5b98c89318133d4736b2bd1abcc1866bab\n     */\n    +getExpiration?: (url: string) => ?number,\n\n    /**\n     * A callback used to determine if a particular URL's result should be\n     * cached or not. This defaults to only allowing JS file extensions to be\n     * stored. This callback should return null for the default behavior to\n     * apply.\n     */\n    +isCacheable?: (url: string) => ?boolean,\n\n    /**\n     * Callback invoked if a retry occurs.\n     * This should return null for the default behavior to apply, true to allow\n     * the retry, and false to block further retries.\n     *\n     * Returning a non-boolean value causes superagent to do its default\n     * behavior, which is:\n     * - allow retry for all 500 errors except 501\n     * - allow retry for err.code set to any:\n     *      ['ECONNRESET', 'ETIMEDOUT', 'EADDRINFO', 'ESOCKETTIMEDOUT']\n     * - allow retry if err.timeout is truthy and err.code is 'ECONNABORTED`\n     * - allow retry if err.crossDomain is truthy\n     */\n    +shouldRetry?: CallbackHandler,\n\n    /**\n     * Call to obtain a cache-safe identifier the currently handled request.\n     *\n     * This is used to identify the request when comparing with cached\n     * responses so that we can determine if a response was fulfilled from\n     * cache or from a fresh request.\n     *\n     * Without an implementation of this method, it is not possible to\n     * determine if something is from cache or not.\n     */\n    +getCacheID?: () => string,\n};\n\n/**\n * Represents an environment that can perform renders.\n *\n * This allows for simple rendering strategies where each render is completely\n * standalong (as per the old react-render-server), or more complex rendering\n * strategies where some amount of the rendering environment state is shared\n * across renders.\n */\nexport interface IRenderEnvironment {\n    /**\n     * Generate a render result for the given url.\n     *\n     * @param {string} url The URL that is to be rendered. This is always\n     * relative to the host and so does not contain protocol, hostname, nor port\n     * information.\n     * @param {RenderAPI} renderAPI An API of utilities for assisting with the\n     * render operation.\n     * @returns {Promise<RenderResult>} The result of the render that is to be\n     * returned by the gateway service as the response to the render request.\n     * This includes the body of the response and the status code information.\n     */\n    render(url: string, renderAPI: RenderAPI): Promise<RenderResult>;\n}\n\n/**\n * Configuration of secrets lookup.\n *\n * One variation provides a Google Cloud KMS configuration; the other provides\n * means to map secrets dynamically.\n */\nexport type SecretsConfig =\n    | {\n          /**\n           * A Google Cloud KMS crpyto key path. This is required in\n           * production.\n           */\n          cryptoKeyPath: string,\n      }\n    | {\n          /**\n           * The absolute path of the root folder for the service.\n           */\n          serviceRootPath: string,\n          /**\n           * A function used to lookup a secret by name.\n           */\n          lookupFn: (name: string, config: string) => ?SecretString,\n      };\n"],"mappings":""}