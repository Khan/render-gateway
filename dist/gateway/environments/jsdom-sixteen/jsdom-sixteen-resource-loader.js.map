{"version":3,"sources":["../../../../src/gateway/environments/jsdom-sixteen/jsdom-sixteen-resource-loader.js"],"names":["JSDOMSixteenResourceLoader","ResourceLoader","EMPTY_RESPONSE","Promise","resolve","Buffer","from","constructor","renderAPI","requestOptions","DefaultRequestOptions","Error","_active","_renderAPI","_requestOptions","_agents","_getAgent","url","parsedURL","URL","agent","protocol","isActive","close","key","Object","keys","destroy","fetch","options","logger","isInlineData","startsWith","readableURLForLogging","warn","JSFileRegex","test","silly","abortableFetch","handleInactive","then","response","text","abort"],"mappings":"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","sourcesContent":["// @flow\nimport {URL} from \"url\";\nimport type {Agent as HttpAgent} from \"http\";\nimport type {Agent as HttpsAgent} from \"https\";\nimport {ResourceLoader} from \"jsdom\";\nimport type {FetchOptions} from \"jsdom\";\nimport {getAgentForURL} from \"../../../shared/index.js\";\nimport {\n    DefaultRequestOptions,\n    request,\n    abortInFlightRequests,\n} from \"../../request.js\";\nimport {applyAbortablePromisesPatch} from \"./apply-abortable-promises-patch.js\";\n\nimport type {RequestOptions, RenderAPI} from \"../../types.js\";\n\n/**\n * A ResourceLoader implementation for JSDOM sixteen-compatible versions of\n * JSDOM that only allows for fetching JS files.\n *\n * A JS file request is identified by the regular expression:\n *   /^.*\\.js(?:\\?.*)?/g\n */\nexport class JSDOMSixteenResourceLoader extends ResourceLoader {\n    /**\n     * Used to indicate if any pending requests are still needed so that we\n     * can report when an unused request is fulfilled.\n     */\n    _active: boolean;\n    _renderAPI: RenderAPI;\n    _requestOptions: RequestOptions;\n    _agents: {[protocol: string]: HttpAgent | HttpsAgent};\n\n    static get EMPTY_RESPONSE(): Promise<Buffer> {\n        return Promise.resolve(Buffer.from(\"\"));\n    }\n\n    /**\n     * Create instance of the resource loader.\n     *\n     * @param {RequestFn} requestFn\n     * The function responsibly for fulfilling GET requests for URLs.\n     */\n    constructor(\n        renderAPI: RenderAPI,\n        requestOptions?: RequestOptions = DefaultRequestOptions,\n    ) {\n        // Patch before super to make sure promises get an abort.\n        applyAbortablePromisesPatch();\n\n        super();\n\n        if (renderAPI == null) {\n            throw new Error(\"Must provide render API.\");\n        }\n\n        this._active = true;\n        this._renderAPI = renderAPI;\n        this._requestOptions = requestOptions;\n        this._agents = {};\n    }\n\n    _getAgent(url: string): HttpAgent | HttpsAgent {\n        const parsedURL = new URL(url);\n        const agent =\n            this._agents[parsedURL.protocol] || getAgentForURL(parsedURL);\n        this._agents[parsedURL.protocol] = agent;\n        return agent;\n    }\n\n    get isActive(): boolean {\n        return this._active;\n    }\n\n    close(): void {\n        this._active = false;\n        abortInFlightRequests();\n\n        /**\n         * We need to destroy any agents we created or they may retain\n         * sockets that retain references to our JSDOM environment and cause\n         * a memory leak.\n         */\n        for (const key of Object.keys(this._agents)) {\n            this._agents[key].destroy();\n            delete this._agents[key];\n        }\n    }\n\n    fetch(url: string, options?: FetchOptions): ?Promise<Buffer> {\n        const logger = this._renderAPI.logger;\n        const isInlineData = url.startsWith(\"data:\");\n        const readableURLForLogging = isInlineData ? \"inline data\" : url;\n        if (!this._active) {\n            /**\n             * If we get here, then something is trying to fetch when our\n             * environment has closed us down. This could be in the reject\n             * or resolve of a promise, for example.\n             *\n             * If it's inlinedata, it really doesn't matter, so let's log it\n             * only if it's for a file.\n             */\n            if (!isInlineData) {\n                logger.warn(\n                    `File fetch attempted after resource loader close: ${readableURLForLogging}`,\n                );\n            }\n\n            /**\n             * Though we intentionally don't want to load this file, we can't\n             * just return null per the spec as this can break promise\n             * resolutions that are relying on this file. Instead, we resolve\n             * as an empty string so things can tidy up properly.\n             */\n            return JSDOMSixteenResourceLoader.EMPTY_RESPONSE;\n        }\n\n        /**\n         * We must still be active.\n         * If this request is not a JavaScript file, we are going to return an\n         * empty response as we don't care about non-JS resources.\n         */\n        const JSFileRegex = /^.*\\.js(?:\\?.*)?/g;\n        if (!JSFileRegex.test(url)) {\n            logger.silly(`EMPTY: ${readableURLForLogging}`);\n\n            /**\n             * Though we intentionally don't want to load this file, we can't\n             * just return null per the spec as this can break promise\n             * resolutions that are relying on this file. Instead, we resolve\n             * as an empty string so things can tidy up properly.\n             */\n            return JSDOMSixteenResourceLoader.EMPTY_RESPONSE;\n        }\n\n        /**\n         * This must be a JavaScript file request. Let's make a request for the\n         * file and then handle it coming back.\n         */\n        const abortableFetch = request(logger, url, {\n            ...this._requestOptions,\n            agent: this._getAgent(url),\n        });\n        const handleInactive = abortableFetch.then((response) => {\n            if (!this._active) {\n                logger.silly(\n                    `File requested but never used: ${readableURLForLogging}`,\n                );\n\n                /**\n                 * Just return an empty buffer so no code executes. The\n                 * request function passed at construction will have handled\n                 * caching of the real file request.\n                 */\n                return Buffer.from(\"\");\n            }\n            return Buffer.from(response.text);\n        });\n\n        /**\n         * We have to turn this back into an abortable promise so that JSDOM\n         * can abort it when closing, if it needs to.\n         */\n        (handleInactive: any).abort = abortableFetch.abort;\n        return handleInactive;\n    }\n}\n"],"file":"jsdom-sixteen-resource-loader.js"}