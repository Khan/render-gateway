{"version":3,"file":"jsdom-sixteen-resource-loader.js","names":["JSDOMSixteenResourceLoader","ResourceLoader","EMPTY_RESPONSE","Promise","resolve","Buffer","from","constructor","renderAPI","requestOptions","DefaultRequestOptions","handleFetchResult","applyAbortablePromisesPatch","KAError","Errors","Internal","_active","_renderAPI","_requestOptions","_agents","_handleFetchResult","_getAgent","url","parsedURL","URL","agent","protocol","getAgentForURL","isActive","close","key","Object","keys","destroy","fetch","options","logger","isInlineData","startsWith","readableURLForLogging","warn","JSFileRegex","test","silly","abortableFetch","request","handleInactive","then","response","aborted","info","text","finalResult","abort","defineProperty","get"],"sources":["../../../../src/gateway/environments/jsdom-sixteen/jsdom-sixteen-resource-loader.js"],"sourcesContent":["// @flow\nimport {URL} from \"url\";\nimport type {Agent as HttpAgent} from \"http\";\nimport type {Agent as HttpsAgent} from \"https\";\nimport {ResourceLoader} from \"jsdom\";\nimport type {FetchOptions} from \"jsdom\";\nimport {getAgentForURL, KAError} from \"../../../shared/index.js\";\nimport {Errors} from \"../../../ka-shared/index.js\";\nimport {DefaultRequestOptions, request} from \"../../request.js\";\nimport {applyAbortablePromisesPatch} from \"./apply-abortable-promises-patch.js\";\n\nimport type {RequestOptions, RenderAPI} from \"../../types.js\";\n\n/**\n * A ResourceLoader implementation for JSDOM sixteen-compatible versions of\n * JSDOM that only allows for fetching JS files, and provides the ability to\n * handle and modify the fetch return result.\n *\n * This can be useful for various things, such as intercepting script requests\n * to execute them in a different manner than letting the DOM use a script tag.\n * The return result could then be an empty string rather than the full script.\n *\n * The caller is responsible for maintaining script order based on call order.\n *\n * A JS file request is identified by the regular expression:\n *   /^.*\\.js(?:\\?.*)?/g\n */\nexport class JSDOMSixteenResourceLoader extends ResourceLoader {\n    /**\n     * Used to indicate if any pending requests are still needed so that we\n     * can report when an unused request is fulfilled.\n     */\n    _active: boolean;\n    _renderAPI: RenderAPI;\n    _requestOptions: RequestOptions;\n    _agents: {[protocol: string]: HttpAgent | HttpsAgent};\n    _handleFetchResult: ?(\n        result: ?Promise<Buffer>,\n        url: string,\n        options?: FetchOptions,\n    ) => ?Promise<Buffer>;\n\n    static get EMPTY_RESPONSE(): Promise<Buffer> {\n        return Promise.resolve(Buffer.from(\"\"));\n    }\n\n    /**\n     * Create instance of the resource loader.\n     *\n     * @param {RenderAPI} RenderAPI The render API that provides things like\n     * the logger.\n     * @param {RequestOptions} [requestOptions] Options that calibrate how\n     * requests are performed for this loader.\n     * @param {(result: ?Promise<Buffer>, url: string, options?: FetchOptions) => ?Promise<Buffer>}\n     * A callback that is invoked with the promise result. This can be used\n     * to ensure additional work is done on each request within the loader\n     * cycle, before the JSDOM call receives the result.\n     */\n    constructor(\n        renderAPI: RenderAPI,\n        requestOptions?: RequestOptions = DefaultRequestOptions,\n        handleFetchResult?: (\n            result: ?Promise<Buffer>,\n            url: string,\n            options?: FetchOptions,\n        ) => ?Promise<Buffer>,\n    ) {\n        // Patch before super to make sure promises get an abort.\n        applyAbortablePromisesPatch();\n\n        super();\n\n        if (renderAPI == null) {\n            throw new KAError(\"Must provide render API.\", Errors.Internal);\n        }\n\n        this._active = true;\n        this._renderAPI = renderAPI;\n        this._requestOptions = requestOptions;\n        this._agents = {};\n        this._handleFetchResult = handleFetchResult;\n    }\n\n    _getAgent(url: string): HttpAgent | HttpsAgent {\n        const parsedURL = new URL(url);\n        const agent =\n            this._agents[parsedURL.protocol] || getAgentForURL(parsedURL);\n        this._agents[parsedURL.protocol] = agent;\n        return agent;\n    }\n\n    get isActive(): boolean {\n        return this._active;\n    }\n\n    close(): void {\n        this._active = false;\n\n        /**\n         * We need to destroy any agents we created or they may retain\n         * sockets that retain references to our JSDOM environment and cause\n         * a memory leak.\n         */\n        for (const key of Object.keys(this._agents)) {\n            this._agents[key].destroy();\n            delete this._agents[key];\n        }\n    }\n\n    fetch(url: string, options?: FetchOptions): ?Promise<Buffer> {\n        const logger = this._renderAPI.logger;\n        const isInlineData = url.startsWith(\"data:\");\n        const readableURLForLogging = isInlineData ? \"inline data\" : url;\n        if (!this._active) {\n            /**\n             * If we get here, then something is trying to fetch when our\n             * environment has closed us down. This could be in the reject\n             * or resolve of a promise, for example.\n             *\n             * If it's inlinedata, it really doesn't matter, so let's log it\n             * only if it's for a file.\n             */\n            if (!isInlineData) {\n                logger.warn(\n                    `File fetch attempted after resource loader close: ${readableURLForLogging}`,\n                );\n            }\n\n            /**\n             * Though we intentionally don't want to load this file, we can't\n             * just return null per the spec as this can break promise\n             * resolutions that are relying on this file. Instead, we resolve\n             * as an empty string so things can tidy up properly.\n             */\n            return JSDOMSixteenResourceLoader.EMPTY_RESPONSE;\n        }\n\n        /**\n         * We must still be active.\n         * If this request is not a JavaScript file, we are going to return an\n         * empty response as we don't care about non-JS resources.\n         */\n        const JSFileRegex = /^.*\\.js(?:\\?.*)?/g;\n        if (!JSFileRegex.test(url)) {\n            logger.silly(`EMPTY: ${readableURLForLogging}`);\n\n            /**\n             * Though we intentionally don't want to load this file, we can't\n             * just return null per the spec as this can break promise\n             * resolutions that are relying on this file. Instead, we resolve\n             * as an empty string so things can tidy up properly.\n             */\n            return JSDOMSixteenResourceLoader.EMPTY_RESPONSE;\n        }\n\n        /**\n         * This must be a JavaScript file request. Let's make a request for the\n         * file and then handle it coming back.\n         */\n        const abortableFetch = request(logger, url, {\n            ...this._requestOptions,\n            agent: this._getAgent(url),\n        });\n        const handleInactive = abortableFetch.then((response) => {\n            const {aborted} = abortableFetch;\n            if (!this._active || aborted) {\n                if (!aborted) {\n                    logger.info(\n                        `File requested but never used: ${readableURLForLogging}`,\n                    );\n                }\n\n                /**\n                 * Just return an empty buffer so no code executes. The\n                 * request function passed at construction will have handled\n                 * caching of the real file request.\n                 */\n                return Buffer.from(\"\");\n            }\n\n            /**\n             * Our requests are always buffered.\n             *\n             * This is OK because we limit our requests to only text files.\n             * If this code were downloading binary data, this would not be\n             * helpful and we may want to consider using the default buffer\n             * setup that only buffers for things where a parser is available.\n             *\n             * Let's worry about that later.\n             */\n            return Buffer.from(response.text);\n        });\n\n        /**\n         * If we have a custom handler, we now let that do work.\n         */\n        const finalResult =\n            this._handleFetchResult == null\n                ? handleInactive\n                : this._handleFetchResult(handleInactive, url, options);\n\n        /**\n         * We have to turn this back into an abortable promise so that JSDOM\n         * can abort it when closing, if it needs to.\n         */\n        (finalResult: any).abort = abortableFetch.abort;\n        Object.defineProperty((finalResult: any), \"aborted\", {\n            get: () => abortableFetch.aborted,\n        });\n\n        return finalResult;\n    }\n}\n"],"mappings":"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"}