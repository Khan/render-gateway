{"version":3,"file":"jsdom-sixteen-resource-loader.js","names":["JSDOMSixteenResourceLoader","ResourceLoader","EMPTY_RESPONSE","Promise","resolve","Buffer","from","constructor","renderAPI","requestOptions","DefaultRequestOptions","handleFetchResult","KAError","Errors","Internal","_active","_renderAPI","_requestOptions","_agents","_handleFetchResult","_getAgent","url","parsedURL","URL","agent","protocol","isActive","close","key","Object","keys","destroy","fetch","options","logger","isInlineData","startsWith","readableURLForLogging","warn","JSFileRegex","test","silly","abortableFetch","handleInactive","then","response","aborted","info","text","finalResult","abort","defineProperty","get"],"sources":["../../../../src/gateway/environments/jsdom-sixteen/jsdom-sixteen-resource-loader.js"],"sourcesContent":["// @flow\nimport {URL} from \"url\";\nimport type {Agent as HttpAgent} from \"http\";\nimport type {Agent as HttpsAgent} from \"https\";\nimport {ResourceLoader} from \"jsdom\";\nimport type {FetchOptions} from \"jsdom\";\nimport {getAgentForURL, KAError} from \"../../../shared/index.js\";\nimport {Errors} from \"../../../ka-shared/index.js\";\nimport {DefaultRequestOptions, request} from \"../../request.js\";\nimport {applyAbortablePromisesPatch} from \"./apply-abortable-promises-patch.js\";\n\nimport type {RequestOptions, RenderAPI} from \"../../types.js\";\n\n/**\n * A ResourceLoader implementation for JSDOM sixteen-compatible versions of\n * JSDOM that only allows for fetching JS files, and provides the ability to\n * handle and modify the fetch return result.\n *\n * This can be useful for various things, such as intercepting script requests\n * to execute them in a different manner than letting the DOM use a script tag.\n * The return result could then be an empty string rather than the full script.\n *\n * The caller is responsible for maintaining script order based on call order.\n *\n * A JS file request is identified by the regular expression:\n *   /^.*\\.js(?:\\?.*)?/g\n */\nexport class JSDOMSixteenResourceLoader extends ResourceLoader {\n    /**\n     * Used to indicate if any pending requests are still needed so that we\n     * can report when an unused request is fulfilled.\n     */\n    _active: boolean;\n    _renderAPI: RenderAPI;\n    _requestOptions: RequestOptions;\n    _agents: {[protocol: string]: HttpAgent | HttpsAgent};\n    _handleFetchResult: ?(\n        result: ?Promise<Buffer>,\n        url: string,\n        options?: FetchOptions,\n    ) => ?Promise<Buffer>;\n\n    static get EMPTY_RESPONSE(): Promise<Buffer> {\n        return Promise.resolve(Buffer.from(\"\"));\n    }\n\n    /**\n     * Create instance of the resource loader.\n     *\n     * @param {RenderAPI} RenderAPI The render API that provides things like\n     * the logger.\n     * @param {RequestOptions} [requestOptions] Options that calibrate how\n     * requests are performed for this loader.\n     * @param {(result: ?Promise<Buffer>, url: string, options?: FetchOptions) => ?Promise<Buffer>}\n     * A callback that is invoked with the promise result. This can be used\n     * to ensure additional work is done on each request within the loader\n     * cycle, before the JSDOM call receives the result.\n     */\n    constructor(\n        renderAPI: RenderAPI,\n        requestOptions?: RequestOptions = DefaultRequestOptions,\n        handleFetchResult?: (\n            result: ?Promise<Buffer>,\n            url: string,\n            options?: FetchOptions,\n        ) => ?Promise<Buffer>,\n    ) {\n        // Patch before super to make sure promises get an abort.\n        applyAbortablePromisesPatch();\n\n        super();\n\n        if (renderAPI == null) {\n            throw new KAError(\"Must provide render API.\", Errors.Internal);\n        }\n\n        this._active = true;\n        this._renderAPI = renderAPI;\n        this._requestOptions = requestOptions;\n        this._agents = {};\n        this._handleFetchResult = handleFetchResult;\n    }\n\n    _getAgent(url: string): HttpAgent | HttpsAgent {\n        const parsedURL = new URL(url);\n        const agent =\n            this._agents[parsedURL.protocol] || getAgentForURL(parsedURL);\n        this._agents[parsedURL.protocol] = agent;\n        return agent;\n    }\n\n    get isActive(): boolean {\n        return this._active;\n    }\n\n    close(): void {\n        this._active = false;\n\n        /**\n         * We need to destroy any agents we created or they may retain\n         * sockets that retain references to our JSDOM environment and cause\n         * a memory leak.\n         */\n        for (const key of Object.keys(this._agents)) {\n            this._agents[key].destroy();\n            delete this._agents[key];\n        }\n    }\n\n    fetch(url: string, options?: FetchOptions): ?Promise<Buffer> {\n        const logger = this._renderAPI.logger;\n        const isInlineData = url.startsWith(\"data:\");\n        const readableURLForLogging = isInlineData ? \"inline data\" : url;\n        if (!this._active) {\n            /**\n             * If we get here, then something is trying to fetch when our\n             * environment has closed us down. This could be in the reject\n             * or resolve of a promise, for example.\n             *\n             * If it's inlinedata, it really doesn't matter, so let's log it\n             * only if it's for a file.\n             */\n            if (!isInlineData) {\n                logger.warn(\n                    `File fetch attempted after resource loader close: ${readableURLForLogging}`,\n                );\n            }\n\n            /**\n             * Though we intentionally don't want to load this file, we can't\n             * just return null per the spec as this can break promise\n             * resolutions that are relying on this file. Instead, we resolve\n             * as an empty string so things can tidy up properly.\n             */\n            return JSDOMSixteenResourceLoader.EMPTY_RESPONSE;\n        }\n\n        /**\n         * We must still be active.\n         * If this request is not a JavaScript file, we are going to return an\n         * empty response as we don't care about non-JS resources.\n         */\n        const JSFileRegex = /^.*\\.js(?:\\?.*)?/g;\n        if (!JSFileRegex.test(url)) {\n            logger.silly(`EMPTY: ${readableURLForLogging}`);\n\n            /**\n             * Though we intentionally don't want to load this file, we can't\n             * just return null per the spec as this can break promise\n             * resolutions that are relying on this file. Instead, we resolve\n             * as an empty string so things can tidy up properly.\n             */\n            return JSDOMSixteenResourceLoader.EMPTY_RESPONSE;\n        }\n\n        /**\n         * This must be a JavaScript file request. Let's make a request for the\n         * file and then handle it coming back.\n         */\n        const abortableFetch = request(logger, url, {\n            ...this._requestOptions,\n            agent: this._getAgent(url),\n        });\n        const handleInactive = abortableFetch.then((response) => {\n            const {aborted} = abortableFetch;\n            if (!this._active || aborted) {\n                if (!aborted) {\n                    logger.info(\n                        `File requested but never used: ${readableURLForLogging}`,\n                    );\n                }\n\n                /**\n                 * Just return an empty buffer so no code executes. The\n                 * request function passed at construction will have handled\n                 * caching of the real file request.\n                 */\n                return Buffer.from(\"\");\n            }\n\n            /**\n             * Our requests are always buffered.\n             *\n             * This is OK because we limit our requests to only text files.\n             * If this code were downloading binary data, this would not be\n             * helpful and we may want to consider using the default buffer\n             * setup that only buffers for things where a parser is available.\n             *\n             * Let's worry about that later.\n             */\n            return Buffer.from(response.text);\n        });\n\n        /**\n         * If we have a custom handler, we now let that do work.\n         */\n        const finalResult =\n            this._handleFetchResult == null\n                ? handleInactive\n                : this._handleFetchResult(handleInactive, url, options);\n\n        /**\n         * We have to turn this back into an abortable promise so that JSDOM\n         * can abort it when closing, if it needs to.\n         */\n        (finalResult: any).abort = abortableFetch.abort;\n        Object.defineProperty((finalResult: any), \"aborted\", {\n            get: () => abortableFetch.aborted,\n        });\n\n        return finalResult;\n    }\n}\n"],"mappings":"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"}