{"version":3,"sources":["../../../../src/gateway/environments/jsdom-sixteen/jsdom-sixteen-resource-loader.js"],"names":["JSDOMSixteenResourceLoader","ResourceLoader","EMPTY_RESPONSE","Promise","resolve","Buffer","from","constructor","renderAPI","requestOptions","DefaultRequestOptions","handleFetchResult","KAError","Errors","Internal","_active","_renderAPI","_requestOptions","_agents","_handleFetchResult","_getAgent","url","parsedURL","URL","agent","protocol","isActive","close","key","Object","keys","destroy","fetch","options","logger","isInlineData","startsWith","readableURLForLogging","warn","JSFileRegex","test","silly","abortableFetch","handleInactive","then","response","text","finalResult","abort"],"mappings":"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","sourcesContent":["// @flow\nimport {URL} from \"url\";\nimport type {Agent as HttpAgent} from \"http\";\nimport type {Agent as HttpsAgent} from \"https\";\nimport {ResourceLoader} from \"jsdom\";\nimport type {FetchOptions} from \"jsdom\";\nimport {getAgentForURL, KAError} from \"../../../shared/index.js\";\nimport {Errors} from \"../../../ka-shared/index.js\";\nimport {DefaultRequestOptions, request} from \"../../request.js\";\nimport {applyAbortablePromisesPatch} from \"./apply-abortable-promises-patch.js\";\n\nimport type {RequestOptions, RenderAPI} from \"../../types.js\";\n\n/**\n * A ResourceLoader implementation for JSDOM sixteen-compatible versions of\n * JSDOM that only allows for fetching JS files, and provides the ability to\n * handle and modify the fetch return result.\n *\n * This can be useful for various things, such as intercepting script requests\n * to execute them in a different manner than letting the DOM use a script tag.\n * The return result could then be an empty string rather than the full script.\n *\n * The caller is responsible for maintaining script order based on call order.\n *\n * A JS file request is identified by the regular expression:\n *   /^.*\\.js(?:\\?.*)?/g\n */\nexport class JSDOMSixteenResourceLoader extends ResourceLoader {\n    /**\n     * Used to indicate if any pending requests are still needed so that we\n     * can report when an unused request is fulfilled.\n     */\n    _active: boolean;\n    _renderAPI: RenderAPI;\n    _requestOptions: RequestOptions;\n    _agents: {[protocol: string]: HttpAgent | HttpsAgent};\n    _handleFetchResult: ?(\n        result: ?Promise<Buffer>,\n        url: string,\n        options?: FetchOptions,\n    ) => ?Promise<Buffer>;\n\n    static get EMPTY_RESPONSE(): Promise<Buffer> {\n        return Promise.resolve(Buffer.from(\"\"));\n    }\n\n    /**\n     * Create instance of the resource loader.\n     *\n     * @param {RenderAPI} RenderAPI The render API that provides things like\n     * the logger.\n     * @param {RequestOptions} [requestOptions] Options that calibrate how\n     * requests are performed for this loader.\n     * @param {(result: ?Promise<Buffer>, url: string, options?: FetchOptions) => ?Promise<Buffer>}\n     * A callback that is invoked with the promise result. This can be used\n     * to ensure additional work is done on each request within the loader\n     * cycle, before the JSDOM call receives the result.\n     */\n    constructor(\n        renderAPI: RenderAPI,\n        requestOptions?: RequestOptions = DefaultRequestOptions,\n        handleFetchResult?: (\n            result: ?Promise<Buffer>,\n            url: string,\n            options?: FetchOptions,\n        ) => ?Promise<Buffer>,\n    ) {\n        // Patch before super to make sure promises get an abort.\n        applyAbortablePromisesPatch();\n\n        super();\n\n        if (renderAPI == null) {\n            throw new KAError(\"Must provide render API.\", Errors.Internal);\n        }\n\n        this._active = true;\n        this._renderAPI = renderAPI;\n        this._requestOptions = requestOptions;\n        this._agents = {};\n        this._handleFetchResult = handleFetchResult;\n    }\n\n    _getAgent(url: string): HttpAgent | HttpsAgent {\n        const parsedURL = new URL(url);\n        const agent =\n            this._agents[parsedURL.protocol] || getAgentForURL(parsedURL);\n        this._agents[parsedURL.protocol] = agent;\n        return agent;\n    }\n\n    get isActive(): boolean {\n        return this._active;\n    }\n\n    close(): void {\n        this._active = false;\n\n        /**\n         * We need to destroy any agents we created or they may retain\n         * sockets that retain references to our JSDOM environment and cause\n         * a memory leak.\n         */\n        for (const key of Object.keys(this._agents)) {\n            this._agents[key].destroy();\n            delete this._agents[key];\n        }\n    }\n\n    fetch(url: string, options?: FetchOptions): ?Promise<Buffer> {\n        const logger = this._renderAPI.logger;\n        const isInlineData = url.startsWith(\"data:\");\n        const readableURLForLogging = isInlineData ? \"inline data\" : url;\n        if (!this._active) {\n            /**\n             * If we get here, then something is trying to fetch when our\n             * environment has closed us down. This could be in the reject\n             * or resolve of a promise, for example.\n             *\n             * If it's inlinedata, it really doesn't matter, so let's log it\n             * only if it's for a file.\n             */\n            if (!isInlineData) {\n                logger.warn(\n                    `File fetch attempted after resource loader close: ${readableURLForLogging}`,\n                );\n            }\n\n            /**\n             * Though we intentionally don't want to load this file, we can't\n             * just return null per the spec as this can break promise\n             * resolutions that are relying on this file. Instead, we resolve\n             * as an empty string so things can tidy up properly.\n             */\n            return JSDOMSixteenResourceLoader.EMPTY_RESPONSE;\n        }\n\n        /**\n         * We must still be active.\n         * If this request is not a JavaScript file, we are going to return an\n         * empty response as we don't care about non-JS resources.\n         */\n        const JSFileRegex = /^.*\\.js(?:\\?.*)?/g;\n        if (!JSFileRegex.test(url)) {\n            logger.silly(`EMPTY: ${readableURLForLogging}`);\n\n            /**\n             * Though we intentionally don't want to load this file, we can't\n             * just return null per the spec as this can break promise\n             * resolutions that are relying on this file. Instead, we resolve\n             * as an empty string so things can tidy up properly.\n             */\n            return JSDOMSixteenResourceLoader.EMPTY_RESPONSE;\n        }\n\n        /**\n         * This must be a JavaScript file request. Let's make a request for the\n         * file and then handle it coming back.\n         */\n        const abortableFetch = request(logger, url, {\n            ...this._requestOptions,\n            agent: this._getAgent(url),\n        });\n        const handleInactive = abortableFetch.then((response) => {\n            if (!this._active) {\n                logger.silly(\n                    `File requested but never used: ${readableURLForLogging}`,\n                );\n\n                /**\n                 * Just return an empty buffer so no code executes. The\n                 * request function passed at construction will have handled\n                 * caching of the real file request.\n                 */\n                return Buffer.from(\"\");\n            }\n            return Buffer.from(response.text);\n        });\n\n        /**\n         * If we have a custom handler, we now let that do work.\n         */\n        const finalResult =\n            this._handleFetchResult == null\n                ? handleInactive\n                : this._handleFetchResult(handleInactive, url, options);\n\n        /**\n         * We have to turn this back into an abortable promise so that JSDOM\n         * can abort it when closing, if it needs to.\n         */\n        (finalResult: any).abort = abortableFetch.abort;\n\n        return finalResult;\n    }\n}\n"],"file":"jsdom-sixteen-resource-loader.js"}