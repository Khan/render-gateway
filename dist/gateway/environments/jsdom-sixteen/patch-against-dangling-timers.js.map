{"version":3,"sources":["../../../../src/gateway/environments/jsdom-sixteen/patch-against-dangling-timers.js"],"names":["patchAgainstDanglingTimers","objToPatch","warned","patchCallbackFnWithGate","obj","fnName","gate","old","callback","args","gatedCallback","isOpen","console","warn","gateOpen","open","close"],"mappings":";;;;;;;AAGA;;;;;;;AAOO,MAAMA,0BAA0B,GAAIC,UAAD,IAAkC;AACxE,MAAIC,MAAM,GAAG,KAAb;;AACA,QAAMC,uBAAuB,GAAG,CAC5BC,GAD4B,EAE5BC,MAF4B,EAG5BC,IAH4B,KAIrB;AACP,UAAMC,GAAG,GAAGH,GAAG,CAACC,MAAD,CAAf;AACA,WAAOD,GAAG,CAACC,MAAD,CAAV;;AACAD,IAAAA,GAAG,CAACC,MAAD,CAAH,GAAc,CAACG,QAAD,EAAW,GAAGC,IAAd,KAAuB;AACjC,YAAMC,aAAa,GAAG,MAAM;AACxB,YAAIJ,IAAI,CAACK,MAAT,EAAiB;AACbH,UAAAA,QAAQ;AACR;AACH;;AACD,YAAI,CAACN,MAAL,EAAa;AACTA,UAAAA,MAAM,GAAG,IAAT;AACA;;;;;AAKA;;AACAU,UAAAA,OAAO,CAACC,IAAR,CAAa,4BAAb;AACH;AACJ,OAfD;;AAgBA,aAAON,GAAG,CAACG,aAAD,EAAgB,GAAGD,IAAnB,CAAV;AACH,KAlBD;AAmBH,GA1BD;AA4BA;;;;;;AAIA,MAAIK,QAAQ,GAAG,IAAf;AACA,QAAMR,IAAI,GAAG;AACTS,IAAAA,IAAI,EAAE,MAAM;AACRD,MAAAA,QAAQ,GAAG,IAAX;AACH,KAHQ;AAITE,IAAAA,KAAK,EAAE,MAAM;AACTF,MAAAA,QAAQ,GAAG,KAAX;AACH,KANQ;;AAOT,QAAIH,MAAJ,GAAsB;AAClB,aAAOG,QAAP;AACH;;AATQ,GAAb;AAYA;;;;;AAIAX,EAAAA,uBAAuB,CAACF,UAAD,EAAa,YAAb,EAA2BK,IAA3B,CAAvB;AACAH,EAAAA,uBAAuB,CAACF,UAAD,EAAa,aAAb,EAA4BK,IAA5B,CAAvB;AACAH,EAAAA,uBAAuB,CAACF,UAAD,EAAa,uBAAb,EAAsCK,IAAtC,CAAvB;AAEA,SAAOA,IAAP;AACH,CAxDM","sourcesContent":["// @flow\nimport type {IGate, ITimerAPI} from \"./types.js\";\n\n/**\n * Patch the timer API to protect against dangling timers.\n *\n * @returns {IGate} A gate API to control when timers should be allowed to run\n * (gate is open), or when we should prevent them running and report dangling\n * timers (gate is closed).\n */\nexport const patchAgainstDanglingTimers = (objToPatch: ITimerAPI): IGate => {\n    let warned = false;\n    const patchCallbackFnWithGate = (\n        obj: any,\n        fnName: string,\n        gate: IGate,\n    ): void => {\n        const old = obj[fnName];\n        delete obj[fnName];\n        obj[fnName] = (callback, ...args) => {\n            const gatedCallback = () => {\n                if (gate.isOpen) {\n                    callback();\n                    return;\n                }\n                if (!warned) {\n                    warned = true;\n                    /**\n                     * This uses console because it runs in the VM, so it\n                     * doesn't have direct access to our winston logging.\n                     * Our virtual JSDOM console manages that.\n                     */\n                    // eslint-disable-next-line no-console\n                    console.warn(\"Dangling timer(s) detected\");\n                }\n            };\n            return old(gatedCallback, ...args);\n        };\n    };\n\n    /**\n     * Make a gate so we can control how the timers are handled.\n     * The gate is default open.\n     */\n    let gateOpen = true;\n    const gate = {\n        open: () => {\n            gateOpen = true;\n        },\n        close: () => {\n            gateOpen = false;\n        },\n        get isOpen(): boolean {\n            return gateOpen;\n        },\n    };\n\n    /**\n     * Patch the timer functions on window so that dangling timers don't kill\n     * us when we close the window.\n     */\n    patchCallbackFnWithGate(objToPatch, \"setTimeout\", gate);\n    patchCallbackFnWithGate(objToPatch, \"setInterval\", gate);\n    patchCallbackFnWithGate(objToPatch, \"requestAnimationFrame\", gate);\n\n    return gate;\n};\n"],"file":"patch-against-dangling-timers.js"}