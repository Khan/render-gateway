{"version":3,"sources":["../../../../src/gateway/environments/jsdom-sixteen/jsdom-sixteen-environment.js"],"names":["MinimalPage","JSDOMSixteenEnvironment","constructor","configuration","url","renderAPI","resourceLoader","traceSession","trace","files","_configuration","getFileList","addLabel","length","Promise","all","map","f","fetchResult","fetch","Error","then","b","content","toString","end","closeables","closeAll","closeable","close","getResourceLoader","_retrieveTargetFiles","jsdomInstance","JSDOM","runScripts","resources","pretendToBeVisual","virtualConsole","logger","push","window","vmContext","getInternalVMContext","runScript","script","options","realScript","Script","runInContext","tmpFnName","patchAgainstDanglingTimers","timerGateAPI","afterEnvSetup","registrationCallbackName","registeredCbName","cb","filename","result","Object","prototype","hasOwnProperty","call","JSON","stringify"],"mappings":"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","sourcesContent":["// @flow\nimport {Script} from \"vm\";\nimport {JSDOM} from \"jsdom\";\nimport {createVirtualConsole} from \"./create-virtual-console.js\";\nimport {patchAgainstDanglingTimers} from \"./patch-against-dangling-timers.js\";\nimport type {\n    IJSDOMSixteenConfiguration,\n    CloseableResourceLoader,\n    IGate,\n    ICloseable,\n} from \"./types.js\";\nimport type {IRenderEnvironment, RenderAPI, RenderResult} from \"../../types.js\";\n\ninterface RenderCallbackFn {\n    /**\n     * Method invoked to create a render result.\n     */\n    (): Promise<RenderResult>;\n}\n\n/**\n * A JS file.\n */\ntype JavaScriptFile = {\n    /**\n     * The content of the file.\n     */\n    content: string,\n\n    /**\n     * The URL of the file.\n     */\n    url: string,\n};\n\nconst MinimalPage = \"<!DOCTYPE html><html><head></head><body></body></html>\";\n\n/**\n * A render environment built to support the JSDOM 16.x API.\n */\nexport class JSDOMSixteenEnvironment implements IRenderEnvironment {\n    _configuration: IJSDOMSixteenConfiguration;\n\n    /**\n     * Create a new instance of this environment.\n     *\n     * @param {IJSDOMSixteenConfiguration} configuration\n     * Configuration for the environment.\n     */\n    constructor(configuration: IJSDOMSixteenConfiguration) {\n        if (configuration == null) {\n            throw new Error(\"Must provide environment configuration\");\n        }\n        this._configuration = configuration;\n    }\n\n    _retrieveTargetFiles: (\n        url: string,\n        renderAPI: RenderAPI,\n        resourceLoader: CloseableResourceLoader,\n    ) => Promise<Array<JavaScriptFile>> = async (\n        url: string,\n        renderAPI: RenderAPI,\n        resourceLoader: CloseableResourceLoader,\n    ): Promise<Array<JavaScriptFile>> => {\n        const traceSession = renderAPI.trace(\n            \"JSDOM16._retrieveTargetFiles\",\n            `JSDOMSixteenEnvironment retrieving files`,\n        );\n        try {\n            /**\n             * First, we need to know what files to execute so that we can\n             * produce a render result, and we need a resource loader so that\n             * we can retrieve those files as well as support retrieving\n             * additional files within our JSDOM environment.\n             */\n            const files = await this._configuration.getFileList(url, renderAPI);\n            traceSession.addLabel(\"fileCount\", files.length);\n\n            /**\n             * Now let's use the resource loader to get the files.\n             * We ignore the `FetchOptions` param of resourceLoader.fetch as we\n             * have nothing to pass there.\n             */\n            return await Promise.all(\n                files.map((f) => {\n                    const fetchResult = resourceLoader.fetch(f);\n                    /**\n                     * Resource loader's fetch can return null. It shouldn't for\n                     * any of these files though, so if it does, let's raise an\n                     * error!\n                     */\n                    if (fetchResult == null) {\n                        throw new Error(\n                            `Unable to retrieve ${f}. ResourceLoader returned null.`,\n                        );\n                    }\n                    /**\n                     * No need to reconnect the abort() in this case since we\n                     * won't be calling it.\n                     */\n                    return fetchResult.then((b) => ({\n                        content: b.toString(),\n                        url: f,\n                    }));\n                }),\n            );\n        } finally {\n            traceSession.end();\n        }\n    };\n\n    /**\n     * Generate a render result for the given url.\n     *\n     * @param {string} url The URL that is to be rendered. This is always\n     * relative to the host and so does not contain protocol, hostname, nor port\n     * information.\n     * @param {RenderAPI} renderAPI An API of utilities for assisting with the\n     * render operation.\n     * @returns {Promise<RenderResult>} The result of the render that is to be\n     * returned by the gateway service as the response to the render request.\n     * This includes the body of the response and the status code information.\n     */\n    render: (\n        url: string,\n        renderAPI: RenderAPI,\n    ) => Promise<RenderResult> = async (\n        url: string,\n        renderAPI: RenderAPI,\n    ): Promise<RenderResult> => {\n        /**\n         * We want to tidy up nicely if there's a problem and also if the render\n         * context is closed, so let's handle that by putting closeable things\n         * into a handy list and providing a way to close them all.\n         */\n        const closeables: Array<ICloseable> = [];\n        const closeAll = () => {\n            for (const closeable of closeables) {\n                // eslint-disable-next-line flowtype/no-unused-expressions\n                closeable?.close?.();\n            }\n        };\n\n        try {\n            /**\n             * We are going to need a resource loader so that we can obtain files\n             * both inside and outside the JSDOM VM.\n             */\n            const resourceLoader = this._configuration.getResourceLoader(\n                url,\n                renderAPI,\n            );\n\n            // Let's get those files!\n            const files = await this._retrieveTargetFiles(\n                url,\n                renderAPI,\n                resourceLoader,\n            );\n\n            /**\n             * We want a JSDOM instance for the url we want to render. This is\n             * where we setup custom resource loading and our virtual console\n             * too.\n             */\n            const jsdomInstance = new JSDOM(MinimalPage, {\n                url,\n                runScripts: \"dangerously\",\n                resources: (resourceLoader: any),\n                pretendToBeVisual: true,\n                virtualConsole: createVirtualConsole(renderAPI.logger),\n            });\n            closeables.push(jsdomInstance.window);\n\n            /**\n             * OK, we know this is a JSDOM instance but we want to expose a nice\n             * wrapper. As part of that wrapper, we want to make it easier to\n             * run scripts (like our rendering JS code) within the VM context.\n             * So, let's create a helper for that.\n             *\n             * We cast the context to any, because otherwise it is typed as an\n             * empty object, which makes life annoying.\n             */\n            const vmContext: any = jsdomInstance.getInternalVMContext();\n            const runScript = (\n                script: string,\n                options?: vm$ScriptOptions,\n            ): any => {\n                const realScript = new Script(script, options);\n                return realScript.runInContext(vmContext);\n            };\n\n            /**\n             * Next, we want to patch timers so we can make sure they don't\n             * fire after we are done (and so we can catch dangling timers if\n             * necessary). To do this, we are going to hang the timer API off\n             * the vmContext and then execute it from inside the context.\n             * Super magic.\n             */\n            const tmpFnName = \"__tmp_patchTimers\";\n            vmContext[tmpFnName] = patchAgainstDanglingTimers;\n            const timerGateAPI: IGate = runScript(`${tmpFnName}(window);`);\n            delete vmContext[tmpFnName];\n            closeables.push(timerGateAPI);\n\n            /**\n             * At this point, we give our configuration an opportunity to\n             * modify the render context.\n             */\n            await this._configuration.afterEnvSetup(url, renderAPI, vmContext);\n\n            /**\n             * At this point, before loading the files for rendering, we must\n             * configure the registration point in our render context.\n             */\n            const {registrationCallbackName} = this._configuration;\n            const registeredCbName = \"__registeredCallback\";\n            vmContext[registrationCallbackName] = (\n                cb: RenderCallbackFn,\n            ): void => {\n                vmContext[registrationCallbackName][registeredCbName] = cb;\n            };\n\n            /**\n             * The context is configured. Now we need to load the files into it\n             * which should cause our registration callback to be invoked.\n             * We pass the filename here so we can get some nicer stack traces.\n             */\n            for (const {content, url} of files) {\n                runScript(content, {filename: url});\n            }\n\n            /**\n             * With the files all loaded, we should have a registered callback.\n             * Let's assert that and then invoke the render process.\n             */\n            if (\n                typeof vmContext[registrationCallbackName][registeredCbName] !==\n                \"function\"\n            ) {\n                throw new Error(\"No render callback was registered.\");\n            }\n\n            /**\n             * And now we run the registered callback inside the VM.\n             */\n            const result: RenderResult = await runScript(`\n    const cb = window[\"${registrationCallbackName}\"][\"${registeredCbName}\"];\n    cb();`);\n\n            /**\n             * Let's make sure that the rendered function returned something\n             * resembling a render result.\n             */\n            if (\n                result == null ||\n                !Object.prototype.hasOwnProperty.call(result, \"body\") ||\n                !Object.prototype.hasOwnProperty.call(result, \"status\") ||\n                !Object.prototype.hasOwnProperty.call(result, \"headers\")\n            ) {\n                throw new Error(\n                    `Malformed render result: ${JSON.stringify(result)}`,\n                );\n            }\n\n            /**\n             * After all that, we should have a result, so let's return it and\n             * let our finally tidy up all the render context we built.\n             */\n            return result;\n        } finally {\n            /**\n             * We need to make sure that whatever happens, we tidy everything\n             * up.\n             */\n            closeAll();\n        }\n    };\n}\n"],"file":"jsdom-sixteen-environment.js"}