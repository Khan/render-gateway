{"version":3,"sources":["../../src/gateway/get-secrets.js"],"names":["getSecrets","cryptoKeyPath","serviceRootPath","lookupFn"],"mappings":";;;;;;;AACA;;AAIA;AACA;AACA;AACO,MAAMA,UAAU,GAAIC,aAAD,IAA6C;AACnE,UAAQ,4BAAR;AACI,SAAK,YAAL;AACI,aAAO,6BAAiB;AACpBA,QAAAA;AADoB,OAAjB,CAAP;;AAIJ;AACI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,aAAO,6BAAiB;AACpBC,QAAAA,eAAe,EAAE,EADG;AAEpBC,QAAAA,QAAQ,EAAE,MAAM;AAFI,OAAjB,CAAP;AAhBR;AAqBH,CAtBM","sourcesContent":["// @flow\nimport {getRuntimeMode, getGCloudSecrets} from \"../ka-shared/index.js\";\n\nimport type {Secrets} from \"../ka-shared/index.js\";\n\n/**\n * Get the secrets table for the service.\n */\nexport const getSecrets = (cryptoKeyPath: string): Promise<Secrets> => {\n    switch (getRuntimeMode()) {\n        case \"production\":\n            return getGCloudSecrets({\n                cryptoKeyPath,\n            });\n\n        default:\n            /**\n             * This should never get called, but I wanted to demonstrate\n             * call usage. We give a false path and return null from the\n             * lookupFn. This means it won't find a secrets config file, and it\n             * it does, it'll still throw from looking up null values.\n             *\n             * A service that needs this behavior would provide a real root path\n             * and a real lookup function.\n             */\n            return getGCloudSecrets({\n                serviceRootPath: \"\",\n                lookupFn: () => null,\n            });\n    }\n};\n"],"file":"get-secrets.js"}