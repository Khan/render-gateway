{"version":3,"file":"requests-from-cache.js","names":["_index","require","_index2","CACHE_ID_PROP_NAME","exports","getResponseSource","response","cacheID","responseCacheID","asUncachedRequest","request","superagentRequest","buffer","asCachedRequest","options","cachePlugin","getExpiration","KAError","Errors","NotAllowed","use","expiration","url","prune","gutResponse","_options$getCacheID","guttedResponse","getCacheID","call"],"sources":["../../src/gateway/requests-from-cache.js"],"sourcesContent":["// @flow\nimport type {Request, Response} from \"superagent\";\nimport {KAError} from \"../shared/index.js\";\nimport {Errors} from \"../ka-shared/index.js\";\nimport type {\n    ResponseSource,\n    RequestOptions,\n    AbortablePromise,\n} from \"./types.js\";\n\n/**\n * This is the name of the property we attach to responses so that we can\n * indicate if a response was from the cache or not.\n */\nexport const CACHE_ID_PROP_NAME: string = \"_cacheID\";\n\n/**\n * Determine the source of a superagent response.\n *\n * @param {SuperAgentResponse} response The response to check.\n * @param {string} cacheID The cacheID for items that are freshly added to the\n * cache in the current request.\n * @returns {ResponseSource} \"cache\" if the response was from cache,\n * \"new request\" if it was not from cache, or \"unknown\" if a cache state cannot\n * be determined.\n */\nexport const getResponseSource = (\n    response: Response,\n    cacheID: ?string,\n): ResponseSource => {\n    // We know that the response doesn't define this prop.\n    // $FlowIgnore[prop-missing]\n    const responseCacheID = response[CACHE_ID_PROP_NAME];\n\n    // If the cacheID to compare or the cache ID of the response are nully,\n    // then we have no idea about the cache state.\n    if (cacheID == null || responseCacheID == null) {\n        return \"unknown\";\n    }\n\n    // If the response cacheID and the passed in cacheID are the same, then\n    // we assume that the response was cached during the current request and\n    // therefore, it was not taken from the existing cache.\n    return responseCacheID === cacheID ? \"new request\" : \"cache\";\n};\n\n/**\n * Turn unbuffered, uncached request into uncached request with buffer.\n *\n * The request will resolve with an additional property to indicate if it was\n * resolved from cache or not.\n *\n * @param {Request} request The request to be modified.\n * @returns {Promise<Response>} A superagent request supporting caching for the\n * given URL.\n */\nexport const asUncachedRequest = (\n    request: Request,\n): AbortablePromise<Response> => {\n    /**\n     * We just return the superagent request. It is already abortable.\n     */\n    const superagentRequest = request.buffer(true);\n    return (superagentRequest: any);\n};\n\n/**\n * Turn unbuffered, uncached request into cached request with or without buffer.\n *\n * Could resolve from cache if caching is enabled and the request has already\n * been fulfilled once. Otherwise, this creates a new request for the URL.\n *\n * The request will resolve with an additional property to indicate if it was\n * resolved from cache or not.\n *\n * @param {RequestOptions} options Used to determine caching setup and whether\n * the request should be buffered or not.\n * @param {Request} request The request to be modified.\n * @returns {Promise<Response>} A superagent request supporting caching for the\n * given URL.\n */\nexport const asCachedRequest = (\n    options: RequestOptions,\n    request: Request,\n): AbortablePromise<Response> => {\n    const {cachePlugin, getExpiration} = options;\n    if (cachePlugin == null) {\n        throw new KAError(\n            \"Cannot cache request without cache plugin instance.\",\n            Errors.NotAllowed,\n        );\n    }\n\n    /**\n     * We need to ensure that what we return has the `abort` method still so\n     * that we can let things like JSDOM call abort on promises.\n     */\n    const superagentRequest = request\n        .use(cachePlugin)\n        .expiration(getExpiration?.(request.url))\n        .prune((response, gutResponse) => {\n            /**\n             * This is called to prune a response before it goes into the\n             * cache.\n             *\n             * We want to use our own `prune` method so that we can track\n             * what comes from cache versus what doesn't.\n             *\n             * But we still do the same thing that superagent-cache would\n             * do, for now.\n             */\n            const guttedResponse = gutResponse(response);\n            const cacheID = options.getCacheID?.();\n            if (cacheID != null) {\n                guttedResponse[CACHE_ID_PROP_NAME] = cacheID;\n            }\n            return guttedResponse;\n        })\n        .buffer(true);\n\n    // We know this is abortable.\n    return (superagentRequest: any);\n};\n"],"mappings":";;;;;;AAEA,IAAAA,MAAA,GAAAC,OAAA;AACA,IAAAC,OAAA,GAAAD,OAAA;AAOA;AACA;AACA;AACA;AACO,MAAME,kBAA0B,GAAG,UAAU;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATAC,OAAA,CAAAD,kBAAA,GAAAA,kBAAA;AAUO,MAAME,iBAAiB,GAAGA,CAC7BC,QAAkB,EAClBC,OAAgB,KACC;EACjB;EACA;EACA,MAAMC,eAAe,GAAGF,QAAQ,CAACH,kBAAkB,CAAC;;EAEpD;EACA;EACA,IAAII,OAAO,IAAI,IAAI,IAAIC,eAAe,IAAI,IAAI,EAAE;IAC5C,OAAO,SAAS;EACpB;;EAEA;EACA;EACA;EACA,OAAOA,eAAe,KAAKD,OAAO,GAAG,aAAa,GAAG,OAAO;AAChE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATAH,OAAA,CAAAC,iBAAA,GAAAA,iBAAA;AAUO,MAAMI,iBAAiB,GAC1BC,OAAgB,IACa;EAC7B;AACJ;AACA;EACI,MAAMC,iBAAiB,GAAGD,OAAO,CAACE,MAAM,CAAC,IAAI,CAAC;EAC9C,OAAQD,iBAAiB;AAC7B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdAP,OAAA,CAAAK,iBAAA,GAAAA,iBAAA;AAeO,MAAMI,eAAe,GAAGA,CAC3BC,OAAuB,EACvBJ,OAAgB,KACa;EAC7B,MAAM;IAACK,WAAW;IAAEC;EAAa,CAAC,GAAGF,OAAO;EAC5C,IAAIC,WAAW,IAAI,IAAI,EAAE;IACrB,MAAM,IAAIE,cAAO,CACb,qDAAqD,EACrDC,cAAM,CAACC,UAAU,CACpB;EACL;;EAEA;AACJ;AACA;AACA;EACI,MAAMR,iBAAiB,GAAGD,OAAO,CAC5BU,GAAG,CAACL,WAAW,CAAC,CAChBM,UAAU,CAACL,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAGN,OAAO,CAACY,GAAG,CAAC,CAAC,CACxCC,KAAK,CAAC,CAACjB,QAAQ,EAAEkB,WAAW,KAAK;IAAA,IAAAC,mBAAA;IAC9B;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACY,MAAMC,cAAc,GAAGF,WAAW,CAAClB,QAAQ,CAAC;IAC5C,MAAMC,OAAO,IAAAkB,mBAAA,GAAGX,OAAO,CAACa,UAAU,cAAAF,mBAAA,uBAAlBA,mBAAA,CAAAG,IAAA,CAAAd,OAAO,CAAe;IACtC,IAAIP,OAAO,IAAI,IAAI,EAAE;MACjBmB,cAAc,CAACvB,kBAAkB,CAAC,GAAGI,OAAO;IAChD;IACA,OAAOmB,cAAc;EACzB,CAAC,CAAC,CACDd,MAAM,CAAC,IAAI,CAAC;;EAEjB;EACA,OAAQD,iBAAiB;AAC7B,CAAC;AAACP,OAAA,CAAAS,eAAA,GAAAA,eAAA"}