{"version":3,"file":"requests-from-cache.js","names":["CACHE_ID_PROP_NAME","getResponseSource","response","cacheID","responseCacheID","asUncachedRequest","request","superagentRequest","buffer","asCachedRequest","options","cachePlugin","getExpiration","KAError","Errors","NotAllowed","use","expiration","url","prune","gutResponse","guttedResponse","getCacheID"],"sources":["../../src/gateway/requests-from-cache.js"],"sourcesContent":["// @flow\nimport type {Request, Response} from \"superagent\";\nimport {KAError} from \"../shared/index.js\";\nimport {Errors} from \"../ka-shared/index.js\";\nimport type {\n    ResponseSource,\n    RequestOptions,\n    AbortablePromise,\n} from \"./types.js\";\n\n/**\n * This is the name of the property we attach to responses so that we can\n * indicate if a response was from the cache or not.\n */\nexport const CACHE_ID_PROP_NAME: string = \"_cacheID\";\n\n/**\n * Determine the source of a superagent response.\n *\n * @param {SuperAgentResponse} response The response to check.\n * @param {string} cacheID The cacheID for items that are freshly added to the\n * cache in the current request.\n * @returns {ResponseSource} \"cache\" if the response was from cache,\n * \"new request\" if it was not from cache, or \"unknown\" if a cache state cannot\n * be determined.\n */\nexport const getResponseSource = (\n    response: Response,\n    cacheID: ?string,\n): ResponseSource => {\n    // We know that the response doesn't define this prop.\n    // $FlowIgnore[prop-missing]\n    const responseCacheID = response[CACHE_ID_PROP_NAME];\n\n    // If the cacheID to compare or the cache ID of the response are nully,\n    // then we have no idea about the cache state.\n    if (cacheID == null || responseCacheID == null) {\n        return \"unknown\";\n    }\n\n    // If the response cacheID and the passed in cacheID are the same, then\n    // we assume that the response was cached during the current request and\n    // therefore, it was not taken from the existing cache.\n    return responseCacheID === cacheID ? \"new request\" : \"cache\";\n};\n\n/**\n * Turn unbuffered, uncached request into uncached request with buffer.\n *\n * The request will resolve with an additional property to indicate if it was\n * resolved from cache or not.\n *\n * @param {Request} request The request to be modified.\n * @returns {Promise<Response>} A superagent request supporting caching for the\n * given URL.\n */\nexport const asUncachedRequest = (\n    request: Request,\n): AbortablePromise<Response> => {\n    /**\n     * We just return the superagent request. It is already abortable.\n     */\n    const superagentRequest = request.buffer(true);\n    return (superagentRequest: any);\n};\n\n/**\n * Turn unbuffered, uncached request into cached request with or without buffer.\n *\n * Could resolve from cache if caching is enabled and the request has already\n * been fulfilled once. Otherwise, this creates a new request for the URL.\n *\n * The request will resolve with an additional property to indicate if it was\n * resolved from cache or not.\n *\n * @param {RequestOptions} options Used to determine caching setup and whether\n * the request should be buffered or not.\n * @param {Request} request The request to be modified.\n * @returns {Promise<Response>} A superagent request supporting caching for the\n * given URL.\n */\nexport const asCachedRequest = (\n    options: RequestOptions,\n    request: Request,\n): AbortablePromise<Response> => {\n    const {cachePlugin, getExpiration} = options;\n    if (cachePlugin == null) {\n        throw new KAError(\n            \"Cannot cache request without cache plugin instance.\",\n            Errors.NotAllowed,\n        );\n    }\n\n    /**\n     * We need to ensure that what we return has the `abort` method still so\n     * that we can let things like JSDOM call abort on promises.\n     */\n    const superagentRequest = request\n        .use(cachePlugin)\n        .expiration(getExpiration?.(request.url))\n        .prune((response, gutResponse) => {\n            /**\n             * This is called to prune a response before it goes into the\n             * cache.\n             *\n             * We want to use our own `prune` method so that we can track\n             * what comes from cache versus what doesn't.\n             *\n             * But we still do the same thing that superagent-cache would\n             * do, for now.\n             */\n            const guttedResponse = gutResponse(response);\n            const cacheID = options.getCacheID?.();\n            if (cacheID != null) {\n                guttedResponse[CACHE_ID_PROP_NAME] = cacheID;\n            }\n            return guttedResponse;\n        })\n        .buffer(true);\n\n    // We know this is abortable.\n    return (superagentRequest: any);\n};\n"],"mappings":";;;;;;;AAEA;;AACA;;AAOA;AACA;AACA;AACA;AACO,MAAMA,kBAA0B,GAAG,UAAnC;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACO,MAAMC,iBAAiB,GAAG,CAC7BC,QAD6B,EAE7BC,OAF6B,KAGZ;EACjB;EACA;EACA,MAAMC,eAAe,GAAGF,QAAQ,CAACF,kBAAD,CAAhC,CAHiB,CAKjB;EACA;;EACA,IAAIG,OAAO,IAAI,IAAX,IAAmBC,eAAe,IAAI,IAA1C,EAAgD;IAC5C,OAAO,SAAP;EACH,CATgB,CAWjB;EACA;EACA;;;EACA,OAAOA,eAAe,KAAKD,OAApB,GAA8B,aAA9B,GAA8C,OAArD;AACH,CAlBM;AAoBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AACO,MAAME,iBAAiB,GAC1BC,OAD6B,IAEA;EAC7B;AACJ;AACA;EACI,MAAMC,iBAAiB,GAAGD,OAAO,CAACE,MAAR,CAAe,IAAf,CAA1B;EACA,OAAQD,iBAAR;AACH,CARM;AAUP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AACO,MAAME,eAAe,GAAG,CAC3BC,OAD2B,EAE3BJ,OAF2B,KAGE;EAC7B,MAAM;IAACK,WAAD;IAAcC;EAAd,IAA+BF,OAArC;;EACA,IAAIC,WAAW,IAAI,IAAnB,EAAyB;IACrB,MAAM,IAAIE,cAAJ,CACF,qDADE,EAEFC,eAAOC,UAFL,CAAN;EAIH;EAED;AACJ;AACA;AACA;;;EACI,MAAMR,iBAAiB,GAAGD,OAAO,CAC5BU,GADqB,CACjBL,WADiB,EAErBM,UAFqB,CAEVL,aAFU,aAEVA,aAFU,uBAEVA,aAAa,CAAGN,OAAO,CAACY,GAAX,CAFH,EAGrBC,KAHqB,CAGf,CAACjB,QAAD,EAAWkB,WAAX,KAA2B;IAAA;;IAC9B;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACY,MAAMC,cAAc,GAAGD,WAAW,CAAClB,QAAD,CAAlC;IACA,MAAMC,OAAO,0BAAGO,OAAO,CAACY,UAAX,wDAAG,yBAAAZ,OAAO,CAAvB;;IACA,IAAIP,OAAO,IAAI,IAAf,EAAqB;MACjBkB,cAAc,CAACrB,kBAAD,CAAd,GAAqCG,OAArC;IACH;;IACD,OAAOkB,cAAP;EACH,CApBqB,EAqBrBb,MArBqB,CAqBd,IArBc,CAA1B,CAb6B,CAoC7B;;EACA,OAAQD,iBAAR;AACH,CAzCM"}