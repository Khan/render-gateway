{"version":3,"sources":["../../src/gateway/requests-from-cache.js"],"names":["FROM_CACHE_PROP_NAME","isFromCache","response","asUncachedRequest","options","request","superagentRequest","buffer","responsePromise","then","res","abortableResponse","abort","asCachedRequest","cachePlugin","getExpiration","KAError","Errors","NotAllowed","FRESHLY_PRUNED","use","expiration","url","prune","gutResponse","guttedResponse"],"mappings":";;;;;;;AAEA;;AACA;;AAGA;AACA;AACA;AACA;AACO,MAAMA,oBAA4B,GAAG,YAArC;AAEP;AACA;AACA;AACA;AACA;AACA;;;;AACO,MAAMC,WAAW,GAAIC,QAAD,IACvBA,QAAQ,CAACF,oBAAD,CAAR,KAAmC,IADhC;AAGP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AACO,MAAMG,iBAAiB,GAAG,CAC7BC,OAD6B,EAE7BC,OAF6B,KAGA;AAC7B;AACJ;AACA;AACA;AACI,QAAMC,iBAAiB,GAAGD,OAAO,CAACE,MAAR,CAAe,IAAf,CAA1B;AACA,QAAMC,eAAe,GAAGF,iBAAiB,CAACG,IAAlB,CAAwBC,GAAD,IAAS;AACpD;AACR;AACA;AACQA,IAAAA,GAAG,CAACV,oBAAD,CAAH,GAA4B,KAA5B;AACA,WAAOU,GAAP;AACH,GANuB,CAAxB;AAQA,QAAMC,iBAA6C,GAAIH,eAAvD;;AACAG,EAAAA,iBAAiB,CAACC,KAAlB,GAA0B,MAAMN,iBAAiB,CAACM,KAAlB,EAAhC;;AACA,SAAOD,iBAAP;AACH,CApBM;AAsBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AACO,MAAME,eAAe,GAAG,CAC3BT,OAD2B,EAE3BC,OAF2B,KAGE;AAC7B,QAAM;AAACS,IAAAA,WAAD;AAAcC,IAAAA;AAAd,MAA+BX,OAArC;;AACA,MAAIU,WAAW,IAAI,IAAnB,EAAyB;AACrB,UAAM,IAAIE,cAAJ,CACF,qDADE,EAEFC,eAAOC,UAFL,CAAN;AAIH;AAED;AACJ;AACA;AACA;AACA;;;AACI,QAAMC,cAAc,GAAG,QAAvB;AAEA;AACJ;AACA;AACA;;AACI,QAAMb,iBAAiB,GAAGD,OAAO,CAC5Be,GADqB,CACjBN,WADiB,EAErBO,UAFqB,CAEVN,aAFU,aAEVA,aAFU,uBAEVA,aAAa,CAAGV,OAAO,CAACiB,GAAX,CAFH,EAGrBC,KAHqB,CAGf,CAACrB,QAAD,EAAWsB,WAAX,KAA2B;AAC9B;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,UAAMC,cAAc,GAAGD,WAAW,CAACtB,QAAD,CAAlC;AACAuB,IAAAA,cAAc,CAACzB,oBAAD,CAAd,GAAuCmB,cAAvC;AACA,WAAOM,cAAP;AACH,GAjBqB,EAkBrBlB,MAlBqB,CAkBd,IAlBc,CAA1B;AAoBA,QAAMC,eAAe,GAAGF,iBAAiB,CAACG,IAAlB,CAAwBC,GAAD,IAAS;AACpD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQA,IAAAA,GAAG,CAACV,oBAAD,CAAH,GACIU,GAAG,CAACV,oBAAD,CAAH,KAA8BmB,cADlC;AAEA,WAAOT,GAAP;AACH,GAxBuB,CAAxB;AA0BA,QAAMC,iBAA6C,GAAIH,eAAvD;;AACAG,EAAAA,iBAAiB,CAACC,KAAlB,GAA0B,MAAMN,iBAAiB,CAACM,KAAlB,EAAhC;;AACA,SAAOD,iBAAP;AACH,CAxEM","sourcesContent":["// @flow\nimport type {Request, Response} from \"superagent\";\nimport {KAError} from \"../shared/index.js\";\nimport {Errors} from \"../ka-shared/index.js\";\nimport type {RequestOptions, AbortablePromise} from \"./types.js\";\n\n/**\n * This is the name of the property we attach to responses so that we can\n * indicate if a response was from the cache or not.\n */\nexport const FROM_CACHE_PROP_NAME: string = \"_fromCache\";\n\n/**\n * Determine if a superagent response was from the cache or not.\n *\n * @param {SuperAgentResponse} response The response to check.\n * @returns {boolean} true if the response was from cache; otherwise false.\n */\nexport const isFromCache = (response: Response): boolean =>\n    response[FROM_CACHE_PROP_NAME] === true;\n\n/**\n * Turn unbuffered, uncached request into uncached request with or without\n * buffer.\n *\n * The request will resolve with an additional property to indicate if it was\n * resolved from cache or not.\n *\n * @param {RequestOptions} options Used to determine if the request should\n * buffer or not.\n * @param {Request} request The request to be modified.\n * @returns {Promise<Response>} A superagent request supporting caching for the\n * given URL.\n */\nexport const asUncachedRequest = (\n    options: RequestOptions,\n    request: Request,\n): AbortablePromise<Response> => {\n    /**\n     * We need to ensure that what we return has the `abort` method still so\n     * that we can let things like JSDOM call abort on promises.\n     */\n    const superagentRequest = request.buffer(true);\n    const responsePromise = superagentRequest.then((res) => {\n        /**\n         * There's no cache, so this is definitely not from cache.\n         */\n        res[FROM_CACHE_PROP_NAME] = false;\n        return res;\n    });\n\n    const abortableResponse: AbortablePromise<Response> = (responsePromise: any);\n    abortableResponse.abort = () => superagentRequest.abort();\n    return abortableResponse;\n};\n\n/**\n * Turn unbuffered, uncached request into cached request with or without buffer.\n *\n * Could resolve from cache if caching is enabled and the request has already\n * been fulfilled once. Otherwise, this creates a new request for the URL.\n *\n * The request will resolve with an additional property to indicate if it was\n * resolved from cache or not.\n *\n * @param {RequestOptions} options Used to determine caching setup and whether\n * the request should be buffered or not.\n * @param {Request} request The request to be modified.\n * @returns {Promise<Response>} A superagent request supporting caching for the\n * given URL.\n */\nexport const asCachedRequest = (\n    options: RequestOptions,\n    request: Request,\n): AbortablePromise<Response> => {\n    const {cachePlugin, getExpiration} = options;\n    if (cachePlugin == null) {\n        throw new KAError(\n            \"Cannot cache request without cache plugin instance.\",\n            Errors.NotAllowed,\n        );\n    }\n\n    /**\n     * TODO(somewhatabstract, WEB-2722): Replace this with the requestID of the\n     * render request. This will then work properly for both in-memory and other\n     * cache types.\n     */\n    const FRESHLY_PRUNED = \"PRUNED\";\n\n    /**\n     * We need to ensure that what we return has the `abort` method still so\n     * that we can let things like JSDOM call abort on promises.\n     */\n    const superagentRequest = request\n        .use(cachePlugin)\n        .expiration(getExpiration?.(request.url))\n        .prune((response, gutResponse) => {\n            /**\n             * This is called to prune a response before it goes into the\n             * cache.\n             *\n             * We want to use our own `prune` method so that we can track\n             * what comes from cache versus what doesn't.\n             *\n             * But we still do the same thing that superagent-cache would\n             * do, for now.\n             */\n            const guttedResponse = gutResponse(response);\n            guttedResponse[FROM_CACHE_PROP_NAME] = FRESHLY_PRUNED;\n            return guttedResponse;\n        })\n        .buffer(true);\n\n    const responsePromise = superagentRequest.then((res) => {\n        /**\n         * Set the FROM_CACHE_PROP_NAME property to a boolean value.\n         *\n         * This works because if it is a brand new response that was just\n         * cached, then the FROM_CACHE_PROP_NAME property is set explicitly\n         * to FRESHLY_PRUNED. Therefore, we know it was not\n         * previously cached. So, we set FROM_CACHE_PROP_NAME property to\n         * false.\n         *\n         * The response we get here is what is in the cache so any\n         * modifications we make are reflected in the cached value (this is\n         * only true for in-memory cache).\n         *\n         * That means that if we get here and the FROM_CACHE_PROP_NAME is\n         * not equal to FRESHLY_PRUNED, it MUST have come from the\n         * cache and not a brand new request, so we can set the\n         * FROM_CACHE_PROP_NAME property to true!\n         *\n         * Cheeky, but it works ðŸ˜ˆ\n         */\n        res[FROM_CACHE_PROP_NAME] =\n            res[FROM_CACHE_PROP_NAME] !== FRESHLY_PRUNED;\n        return res;\n    });\n\n    const abortableResponse: AbortablePromise<Response> = (responsePromise: any);\n    abortableResponse.abort = () => superagentRequest.abort();\n    return abortableResponse;\n};\n"],"file":"requests-from-cache.js"}