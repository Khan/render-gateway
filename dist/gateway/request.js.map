{"version":3,"sources":["../../src/gateway/request.js"],"names":["DefaultRequestOptions","retries","timeout","request","logger","url","options","optionsToUse","traceSession","addLabel","abortableRequest","finalizedPromise","then","res","finally","end","finalizedRequest","abort"],"mappings":";;;;;;;AAIA;;AACA;;AACA;;;;;;;;AAEA;AACA;AACA;AACO,MAAMA,qBAAqC,GAAG;AACjDC,EAAAA,OAAO,EAAE,CADwC;AAEjDC,EAAAA,OAAO,EAAE;AAFwC,CAA9C;AAKP;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACO,MAAMC,OAAO,GAAG,CACnBC,MADmB,EAEnBC,GAFmB,EAGnBC,OAHmB,KAIU;AAC7B,QAAMC,YAAY,mCACXP,qBADW,GAEXM,OAFW,CAAlB;AAKA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,QAAME,YAAY,GAAG,kBAAO,SAAP,EAAiBH,GAAjB,EAAsBD,MAAtB,CAArB;AACAI,EAAAA,YAAY,CAACC,QAAb,CAAsB,KAAtB,EAA6BJ,GAA7B;AACA,QAAMK,gBAAgB,GAAG,8BAAYH,YAAZ,EAA0BH,MAA1B,EAAkCC,GAAlC,CAAzB;AAEA;AACJ;AACA;AACA;AACA;;AACI,QAAMM,gBAAgB,GAAGD,gBAAgB,CACpCE,IADoB,CACdC,GAAD,IAAS;AACXL,IAAAA,YAAY,CAACC,QAAb,CAAsB,WAAtB,EAAmC,oCAAYI,GAAZ,CAAnC;AACAL,IAAAA,YAAY,CAACC,QAAb,CAAsB,YAAtB,EAAoC,IAApC;AACA,WAAOI,GAAP;AACH,GALoB,EAMpBC,OANoB,CAMZ,MAAM;AACXN,IAAAA,YAAY,CAACO,GAAb;AACH,GARoB,CAAzB;AAUA;AACJ;AACA;AACA;;AACI,QAAMC,gBAA4C,GAAIL,gBAAtD;AACA;AACJ;AACA;AACA;AACA;;AACI,MAAIK,gBAAgB,KAAKN,gBAAzB,EAA2C;AACvCM,IAAAA,gBAAgB,CAACC,KAAjB,GAAyB,MAAMP,gBAAgB,CAACO,KAAjB,EAA/B;AACH;;AACD,SAAOD,gBAAP;AACH,CAnDM","sourcesContent":["// @flow\nimport type {Response} from \"superagent\";\nimport type {RequestOptions, AbortablePromise} from \"./types.js\";\nimport type {Logger} from \"../shared/types.js\";\nimport {makeRequest} from \"./make-request.js\";\nimport {isFromCache} from \"./requests-from-cache.js\";\nimport {trace} from \"../shared/index.js\";\n\n/**\n * The defaults used for request options.\n */\nexport const DefaultRequestOptions: RequestOptions = {\n    retries: 2,\n    timeout: 60000,\n};\n\n/**\n * Request a URL.\n *\n * NOTE: The AbortablePromise is only shallowly abortable. If any standard\n * promise methods are called on this, the promise they return no longer will\n * have the abort function. Therefore, you'll need to readd it.\n */\nexport const request = (\n    logger: Logger,\n    url: string,\n    options?: RequestOptions,\n): AbortablePromise<Response> => {\n    const optionsToUse = {\n        ...DefaultRequestOptions,\n        ...options,\n    };\n\n    /**\n     * We don't already have this request in flight, so let's make a new\n     * request.\n     *\n     * First, we start a trace.\n     * Then we make the request.\n     * Then we capture the abort function so we can reattach it later.\n     */\n    const traceSession = trace(`request`, url, logger);\n    traceSession.addLabel(\"url\", url);\n    const abortableRequest = makeRequest(optionsToUse, logger, url);\n\n    /**\n     * Now, let's do the infrastructure bits for tracing this request with\n     * some useful logging data and removing completed requests from our\n     * in flight list.\n     */\n    const finalizedPromise = abortableRequest\n        .then((res) => {\n            traceSession.addLabel(\"fromCache\", isFromCache(res));\n            traceSession.addLabel(\"successful\", true);\n            return res;\n        })\n        .finally(() => {\n            traceSession.end();\n        });\n\n    /**\n     * Finally, we need to turn the promise back into an abortable and add it\n     * to our list of in flight requests.\n     */\n    const finalizedRequest: AbortablePromise<Response> = (finalizedPromise: any);\n    /**\n     * In tests, we might mock the promise API to return the same mock, so\n     * to avoid cyclic abort calls, we only add abort if we're not the same\n     * object.\n     */\n    if (finalizedRequest !== abortableRequest) {\n        finalizedRequest.abort = () => abortableRequest.abort();\n    }\n    return finalizedRequest;\n};\n"],"file":"request.js"}