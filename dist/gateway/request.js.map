{"version":3,"sources":["../../src/gateway/request.js"],"names":["inFlightRequests","abortInFlightRequests","url","Object","keys","request","abort","DefaultRequestOptions","buffer","retries","timeout","logger","options","optionsToUse","inFlight","traceSession","addLabel","abortableRequest","finalizedPromise","then","res","finally","end","finalizedRequest"],"mappings":";;;;;;;AAQA;;AACA;;AACA;;;;;;;;AAEA;;;AAGA,MAAMA,gBAAkC,GAAG,EAA3C;AAEA;;;;AAGO,MAAMC,qBAAqB,GAAG,MAAY;AAC7C,OAAK,MAAMC,GAAX,IAAkBC,MAAM,CAACC,IAAP,CAAYJ,gBAAZ,CAAlB,EAAiD;AAC7C,UAAMK,OAAO,GAAGL,gBAAgB,CAACE,GAAD,CAAhC;AACA,WAAOF,gBAAgB,CAACE,GAAD,CAAvB;AACAG,IAAAA,OAAO,CAACC,KAAR;AACH;AACJ,CANM;AAQP;;;;;;AAGO,MAAMC,qBAAqC,GAAG;AACjDC,EAAAA,MAAM,EAAE,IADyC;AAEjDC,EAAAA,OAAO,EAAE,CAFwC;AAGjDC,EAAAA,OAAO,EAAE;AAHwC,CAA9C;AAMP;;;;;;;;;;;;;;AAWO,MAAML,OAAO,GAAG,CACnBM,MADmB,EAEnBT,GAFmB,EAGnBU,OAHmB,KAIU;AAC7B,QAAMC,YAAY,mCACXN,qBADW,GAEXK,OAFW,CAAlB;AAKA;;;;;;AAIA,QAAME,QAAQ,GAAGd,gBAAgB,CAACE,GAAD,CAAjC;;AACA,MAAIY,QAAQ,IAAI,IAAhB,EAAsB;AAClB,WAAOA,QAAP;AACH;AAED;;;;;;;;;;AAQA,QAAMC,YAAY,GAAG,kBAAO,SAAP,EAAiBb,GAAjB,EAAsBS,MAAtB,CAArB;AACAI,EAAAA,YAAY,CAACC,QAAb,CAAsB,KAAtB,EAA6Bd,GAA7B;AACA,QAAMe,gBAAgB,GAAG,8BAAYJ,YAAZ,EAA0BF,MAA1B,EAAkCT,GAAlC,CAAzB;AAEA;;;;;;AAKA,QAAMgB,gBAAgB,GAAGD,gBAAgB,CACpCE,IADoB,CACdC,GAAD,IAAS;AACXL,IAAAA,YAAY,CAACC,QAAb,CAAsB,WAAtB,EAAmC,oCAAYI,GAAZ,CAAnC;AACAL,IAAAA,YAAY,CAACC,QAAb,CAAsB,YAAtB,EAAoC,IAApC;AACA,WAAOI,GAAP;AACH,GALoB,EAMpBC,OANoB,CAMZ,MAAM;AACX,WAAOrB,gBAAgB,CAACE,GAAD,CAAvB;AACAa,IAAAA,YAAY,CAACO,GAAb;AACH,GAToB,CAAzB;AAWA;;;;;AAIA,QAAMC,gBAA4C,GAAIL,gBAAtD;AACA;;;;;;AAKA,MAAIK,gBAAgB,KAAKN,gBAAzB,EAA2C;AACvCM,IAAAA,gBAAgB,CAACjB,KAAjB,GAAyB,MAAMW,gBAAgB,CAACX,KAAjB,EAA/B;AACH;;AACDN,EAAAA,gBAAgB,CAACE,GAAD,CAAhB,GAAwBqB,gBAAxB;AACA,SAAOA,gBAAP;AACH,CA9DM","sourcesContent":["// @flow\nimport type {Response} from \"superagent\";\nimport type {\n    InFlightRequests,\n    RequestOptions,\n    AbortablePromise,\n} from \"./types.js\";\nimport type {Logger} from \"../shared/types.js\";\nimport {makeRequest} from \"./make-request.js\";\nimport {isFromCache} from \"./requests-from-cache.js\";\nimport {trace} from \"../shared/index.js\";\n\n/**\n * This tracks our inflight requests.\n */\nconst inFlightRequests: InFlightRequests = {};\n\n/**\n * Abort any requests that are inflight and clear the inflight request queue.\n */\nexport const abortInFlightRequests = (): void => {\n    for (const url of Object.keys(inFlightRequests)) {\n        const request = inFlightRequests[url];\n        delete inFlightRequests[url];\n        request.abort();\n    }\n};\n\n/**\n * The defaults used for request options.\n */\nexport const DefaultRequestOptions: RequestOptions = {\n    buffer: true,\n    retries: 2,\n    timeout: 60000,\n};\n\n/**\n * Request a URL.\n *\n * Unlike makeRequest, which makes a new request, this will track inflight\n * requests and if there is one for the request being made, return that instead\n * of making a new one.\n *\n * NOTE: The AbortablePromise is only shallowly abortable. If any standard\n * promise methods are called on this, the promise they return no longer will\n * have the abort function. Therefore, you'll need to readd it.\n */\nexport const request = (\n    logger: Logger,\n    url: string,\n    options?: RequestOptions,\n): AbortablePromise<Response> => {\n    const optionsToUse = {\n        ...DefaultRequestOptions,\n        ...options,\n    };\n\n    /**\n     * Something may have already started this request. If it is already\n     * \"in flight\", let's use it rather than making a whole new one.\n     */\n    const inFlight = inFlightRequests[url];\n    if (inFlight != null) {\n        return inFlight;\n    }\n\n    /**\n     * We don't already have this request in flight, so let's make a new\n     * request.\n     *\n     * First, we start a trace.\n     * Then we make the request.\n     * Then we capture the abort function so we can reattach it later.\n     */\n    const traceSession = trace(`request`, url, logger);\n    traceSession.addLabel(\"url\", url);\n    const abortableRequest = makeRequest(optionsToUse, logger, url);\n\n    /**\n     * Now, let's do the infrastructure bits for tracing this request with\n     * some useful logging data and removing completed requests from our\n     * in flight list.\n     */\n    const finalizedPromise = abortableRequest\n        .then((res) => {\n            traceSession.addLabel(\"fromCache\", isFromCache(res));\n            traceSession.addLabel(\"successful\", true);\n            return res;\n        })\n        .finally(() => {\n            delete inFlightRequests[url];\n            traceSession.end();\n        });\n\n    /**\n     * Finally, we need to turn the promise back into an abortable and add it\n     * to our list of in flight requests.\n     */\n    const finalizedRequest: AbortablePromise<Response> = (finalizedPromise: any);\n    /**\n     * In tests, we might mock the promise API to return the same mock, so\n     * to avoid cyclic abort calls, we only add abort if we're not the same\n     * object.\n     */\n    if (finalizedRequest !== abortableRequest) {\n        finalizedRequest.abort = () => abortableRequest.abort();\n    }\n    inFlightRequests[url] = finalizedRequest;\n    return finalizedRequest;\n};\n"],"file":"request.js"}