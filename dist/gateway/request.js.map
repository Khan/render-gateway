{"version":3,"sources":["../../src/gateway/request.js"],"names":["inFlightRequests","abortInFlightRequests","url","Object","keys","request","abort","DefaultRequestOptions","buffer","retries","timeout","logger","options","optionsToUse","inFlight","traceSession","abortableRequest","abortFn","traceInfo","finalizedPromise","then","res","fromCache","successful","finally","end","finalizedRequest"],"mappings":";;;;;;;AAQA;;AACA;;AACA;;;;;;;;AAEA;;;AAGA,MAAMA,gBAAkC,GAAG,EAA3C;AAEA;;;;AAGO,MAAMC,qBAAqB,GAAG,MAAY;AAC7C,OAAK,MAAMC,GAAX,IAAkBC,MAAM,CAACC,IAAP,CAAYJ,gBAAZ,CAAlB,EAAiD;AAC7C,UAAMK,OAAO,GAAGL,gBAAgB,CAACE,GAAD,CAAhC;AACA,WAAOF,gBAAgB,CAACE,GAAD,CAAvB;AACAG,IAAAA,OAAO,CAACC,KAAR;AACH;AACJ,CANM;AAQP;;;;;;AAGO,MAAMC,qBAAqC,GAAG;AACjDC,EAAAA,MAAM,EAAE,IADyC;AAEjDC,EAAAA,OAAO,EAAE,CAFwC;AAGjDC,EAAAA,OAAO,EAAE;AAHwC,CAA9C;AAMP;;;;;;;;;;;;;;AAWO,MAAML,OAAO,GAAG,CACnBM,MADmB,EAEnBT,GAFmB,EAGnBU,OAHmB,KAIU;AAC7B,QAAMC,YAAY,qBACXN,qBADW,MAEXK,OAFW,CAAlB;AAKA;;;;;;AAIA,QAAME,QAAQ,GAAGd,gBAAgB,CAACE,GAAD,CAAjC;;AACA,MAAIY,QAAQ,IAAI,IAAhB,EAAsB;AAClB,WAAOA,QAAP;AACH;AAED;;;;;;;;;;AAQA,QAAMC,YAAY,GAAG,kBAAO,QAAOb,GAAI,EAAlB,EAAqBS,MAArB,CAArB;AACA,QAAMK,gBAAgB,GAAG,8BAAYH,YAAZ,EAA0BF,MAA1B,EAAkCT,GAAlC,CAAzB;AACA,QAAMe,OAAO,GAAGD,gBAAgB,CAACV,KAAjC;AAEA;;;;;;AAKA,QAAMY,SAAS,GAAG,EAAlB;AACA,QAAMC,gBAAgB,GAAGH,gBAAgB,CACpCI,IADoB,CACdC,GAAD,IAAS;AACXH,IAAAA,SAAS,CAACI,SAAV,GAAsB,oCAAYD,GAAZ,CAAtB;AACAH,IAAAA,SAAS,CAACK,UAAV,GAAuB,IAAvB;AACA,WAAOF,GAAP;AACH,GALoB,EAMpBG,OANoB,CAMZ,MAAM;AACX,WAAOxB,gBAAgB,CAACE,GAAD,CAAvB;AACAa,IAAAA,YAAY,CAACU,GAAb,CAAiBP,SAAjB;AACH,GAToB,CAAzB;AAWA;;;;;AAIA,QAAMQ,gBAA4C,GAAIP,gBAAtD;AACAO,EAAAA,gBAAgB,CAACpB,KAAjB,GAAyBW,OAAzB;AACAjB,EAAAA,gBAAgB,CAACE,GAAD,CAAhB,GAAwBwB,gBAAxB;AACA,SAAOA,gBAAP;AACH,CAxDM","sourcesContent":["// @flow\nimport type {Response} from \"superagent\";\nimport type {\n    InFlightRequests,\n    RequestOptions,\n    AbortablePromise,\n} from \"./types.js\";\nimport type {Logger} from \"../shared/types.js\";\nimport {makeRequest} from \"./make-request.js\";\nimport {isFromCache} from \"./requests-from-cache.js\";\nimport {trace} from \"../ka-shared/index.js\";\n\n/**\n * This tracks our inflight requests.\n */\nconst inFlightRequests: InFlightRequests = {};\n\n/**\n * Abort any requests that are inflight and clear the inflight request queue.\n */\nexport const abortInFlightRequests = (): void => {\n    for (const url of Object.keys(inFlightRequests)) {\n        const request = inFlightRequests[url];\n        delete inFlightRequests[url];\n        request.abort();\n    }\n};\n\n/**\n * The defaults used for request options.\n */\nexport const DefaultRequestOptions: RequestOptions = {\n    buffer: true,\n    retries: 2,\n    timeout: 60000,\n};\n\n/**\n * Request a URL.\n *\n * Unlike makeRequest, which makes a new request, this will track inflight\n * requests and if there is one for the request being made, return that instead\n * of making a new one.\n *\n * NOTE: The AbortablePromise is only shallowly abortable. If any standard\n * promise methods are called on this, the promise they return no longer will\n * have the abort function. Therefore, you'll need to readd it.\n */\nexport const request = (\n    logger: Logger,\n    url: string,\n    options?: RequestOptions,\n): AbortablePromise<Response> => {\n    const optionsToUse = {\n        ...DefaultRequestOptions,\n        ...options,\n    };\n\n    /**\n     * Something may have already started this request. If it is already\n     * \"in flight\", let's use it rather than making a whole new one.\n     */\n    const inFlight = inFlightRequests[url];\n    if (inFlight != null) {\n        return inFlight;\n    }\n\n    /**\n     * We don't already have this request in flight, so let's make a new\n     * request.\n     *\n     * First, we start a trace.\n     * Then we make the request.\n     * Then we capture the abort function so we can reattach it later.\n     */\n    const traceSession = trace(`REQ: ${url}`, logger);\n    const abortableRequest = makeRequest(optionsToUse, logger, url);\n    const abortFn = abortableRequest.abort;\n\n    /**\n     * Now, let's do the infrastructure bits for tracing this request with\n     * some useful logging data and removing completed requests from our\n     * in flight list.\n     */\n    const traceInfo = {};\n    const finalizedPromise = abortableRequest\n        .then((res) => {\n            traceInfo.fromCache = isFromCache(res);\n            traceInfo.successful = true;\n            return res;\n        })\n        .finally(() => {\n            delete inFlightRequests[url];\n            traceSession.end(traceInfo);\n        });\n\n    /**\n     * Finally, we need to turn the promise back into an abortable and add it\n     * to our list of in flight requests.\n     */\n    const finalizedRequest: AbortablePromise<Response> = (finalizedPromise: any);\n    finalizedRequest.abort = abortFn;\n    inFlightRequests[url] = finalizedRequest;\n    return finalizedRequest;\n};\n"],"file":"request.js"}