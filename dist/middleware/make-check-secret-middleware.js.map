{"version":3,"sources":["../../src/middleware/make-check-secret-middleware.js"],"names":["makeProductionMiddleware","options","secretKey","headerName","cryptoKeyPath","secrets","secret","Error","req","res","next","requestSecret","header","status","send","error","makeDevelopmentMiddleware","Promise","resolve","makeCheckSecretMiddleware","authenticationOptions"],"mappings":";;;;;;;AAEA;;AACA;;AAIA,eAAeA,wBAAf,CACIC,OADJ,EAEiC;AAC7B;;;;;;;;;AASA,QAAM;AAACC,IAAAA,SAAD;AAAYC,IAAAA,UAAZ;AAAwBC,IAAAA;AAAxB,MAAyCH,OAA/C;AACA,QAAMI,OAAO,GAAG,MAAM,4BAAWD,aAAX,CAAtB;AACA,QAAME,MAAM,GAAGD,OAAO,CAACH,SAAD,CAAtB;;AACA,MAAII,MAAM,IAAI,IAAd,EAAoB;AAChB,UAAM,IAAIC,KAAJ,CAAU,uBAAV,CAAN;AACH;;AAED,SAAO,UAASC,GAAT,EAAmBC,GAAnB,EAA6BC,IAA7B,EAAuD;AAC1D,UAAMC,aAAa,GAAGH,GAAG,CAACI,MAAJ,CAAWT,UAAX,CAAtB;;AACA,QAAIQ,aAAa,KAAKL,MAAtB,EAA8B;AAC1BG,MAAAA,GAAG,CAACI,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAACC,QAAAA,KAAK,EAAE;AAAR,OAArB;AACA;AACH;;AAEDL,IAAAA,IAAI;AACP,GARD;AASH;;AAED,SAASM,yBAAT,GAEE;AACE;;;AAGA,SAAOC,OAAO,CAACC,OAAR,CAAgB,UACnBV,GADmB,EAEnBC,GAFmB,EAGnBC,IAHmB,EAIf;AACJA,IAAAA,IAAI;AACP,GANM,CAAP;AAOH;AAED;;;;;;;;;AAOO,SAASS,yBAAT,CACHC,qBADG,EAE0B;AAC7B,MAAIA,qBAAqB,IAAI,IAAzB,IAAiC,0CAAqB,YAA1D,EAAwE;AACpE,WAAOpB,wBAAwB,CAACoB,qBAAD,CAA/B;AACH;;AAED,SAAOJ,yBAAyB,EAAhC;AACH","sourcesContent":["// @flow\nimport type {Middleware, $Request, $Response, NextFunction} from \"express\";\nimport {getRuntimeMode} from \"../ka-shared/get-runtime-mode.js\";\nimport {getSecrets} from \"../get-secrets.js\";\n\nimport type {AuthenticationOptions} from \"../types.js\";\n\nasync function makeProductionMiddleware<Req: $Request, Res: $Response>(\n    options: AuthenticationOptions,\n): Promise<Middleware<Req, Res>> {\n    /**\n     * We look up the secret when the middleware is created. That means\n     * that if the secret changes, the server needs to be\n     * restarted/refreshed somehow.\n     *\n     * TODO(somewhatabstract): Add ability to trigger refresh of server -\n     * likely just a killswitch to kill an instace so that GAE spins up new\n     * ones.\n     */\n    const {secretKey, headerName, cryptoKeyPath} = options;\n    const secrets = await getSecrets(cryptoKeyPath);\n    const secret = secrets[secretKey];\n    if (secret == null) {\n        throw new Error(\"Unable to load secret\");\n    }\n\n    return function(req: Req, res: Res, next: NextFunction): void {\n        const requestSecret = req.header(headerName);\n        if (requestSecret !== secret) {\n            res.status(401).send({error: \"Missing or invalid secret\"});\n            return;\n        }\n\n        next();\n    };\n}\n\nfunction makeDevelopmentMiddleware<Req: $Request, Res: $Response>(): Promise<\n    Middleware<Req, Res>,\n> {\n    /**\n     * The secrets middleware is a noop when not in production.\n     */\n    return Promise.resolve(function(\n        req: Req,\n        res: Res,\n        next: NextFunction,\n    ): void {\n        next();\n    });\n}\n\n/**\n * Make the middleware to verify a request's authentication secret.\n *\n * This is a noop when not in production, otherwise this loads the appropriate\n * secret as identified by the options and then uses the configured header name\n * to identify the request header that it is to be matched against.\n */\nexport function makeCheckSecretMiddleware<Req: $Request, Res: $Response>(\n    authenticationOptions?: AuthenticationOptions,\n): Promise<Middleware<Req, Res>> {\n    if (authenticationOptions != null && getRuntimeMode() === \"production\") {\n        return makeProductionMiddleware(authenticationOptions);\n    }\n\n    return makeDevelopmentMiddleware();\n}\n"],"file":"make-check-secret-middleware.js"}