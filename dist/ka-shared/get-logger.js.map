{"version":3,"sources":["../../src/ka-shared/get-logger.js"],"names":["rootLogger","getLogger","request"],"mappings":";;;;;;;AAEA;;AACA;;AACA;;AAGA;;;;AAIA,MAAMA,UAAU,GAAG,yBAAa,qCAAb,EAA+B,+BAA/B,CAAnB;AAEA;;;;;;;;;;;;;;;AAcO,MAAMC,SAAS,GAClBC,OADqB,IAEZ,6BAAiBF,UAAjB,EAA6BE,OAA7B,CAFN","sourcesContent":["// @flow\nimport type {$Request} from \"express\";\nimport {createLogger, getRequestLogger} from \"../shared/index.js\";\nimport {getRuntimeMode} from \"./get-runtime-mode.js\";\nimport {getLogLevel} from \"./get-log-level.js\";\nimport type {Logger, RequestWithLog} from \"../shared/index.js\";\n\n/**\n * Create our top-level logger on module import so that all importers of this\n * file share the same logger.\n */\nconst rootLogger = createLogger(getRuntimeMode(), getLogLevel());\n\n/**\n * Get the logger to use in the current context.\n *\n * When given a request, if that request has a log property, then that logger\n * is returned, otherwise the top-level logger instance is returned. This\n * provides a convenience so that the calling code does not need to know the\n * source of the logger.\n *\n * There is no need for a logger to specifically request the top-level logger\n * as things that are logging should not care. However, in a case where there\n * is no request to use for context, it is equivalent to explicitly requesting\n * the top-level logger. To put it another way, there is no need for a semantic\n * use of getTopLevelLogger as that is not a real use-case.\n */\nexport const getLogger = <TReq: RequestWithLog<$Request>>(\n    request?: TReq,\n): Logger => getRequestLogger(rootLogger, request);\n"],"file":"get-logger.js"}