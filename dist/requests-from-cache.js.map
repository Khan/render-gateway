{"version":3,"sources":["../src/requests-from-cache.js"],"names":["FROM_CACHE_PROP_NAME","isFromCache","response","asUncachedRequest","options","request","superagentRequest","buffer","abortFn","abort","responsePromise","then","res","abortableResponse","asCachedRequest","cachePlugin","getExpiration","Error","FRESHLY_PRUNED","use","expiration","url","prune","gutResponse","guttedResponse"],"mappings":";;;;;;;AAIA;;;;AAIO,MAAMA,oBAA4B,GAAG,YAArC;AAEP;;;;;;;;;AAMO,MAAMC,WAAW,GAAIC,QAAD,IACvBA,QAAQ,CAACF,oBAAD,CAAR,KAAmC,IADhC;AAGP;;;;;;;;;;;;;;;;;AAaO,MAAMG,iBAAiB,GAAG,CAC7BC,OAD6B,EAE7BC,OAF6B,KAGA;AAC7B;;;;AAIA,QAAMC,iBAAiB,GAAGD,OAAO,CAACE,MAAR,CAAeH,OAAO,CAACG,MAAvB,CAA1B;AACA,QAAMC,OAAO,GAAGF,iBAAiB,CAACG,KAAlC;AACA,QAAMC,eAAe,GAAGJ,iBAAiB,CAACK,IAAlB,CAAwBC,GAAD,IAAS;AACpD;;;AAGAA,IAAAA,GAAG,CAACZ,oBAAD,CAAH,GAA4B,KAA5B;AACA,WAAOY,GAAP;AACH,GANuB,CAAxB;AAQA,QAAMC,iBAA6C,GAAIH,eAAvD;AACAG,EAAAA,iBAAiB,CAACJ,KAAlB,GAA0BD,OAA1B;AACA,SAAOK,iBAAP;AACH,CArBM;AAuBP;;;;;;;;;;;;;;;;;;;AAeO,MAAMC,eAAe,GAAG,CAC3BV,OAD2B,EAE3BC,OAF2B,KAGE;AAC7B,QAAM;AAACU,IAAAA,WAAD;AAAcC,IAAAA,aAAd;AAA6BT,IAAAA;AAA7B,MAAuCH,OAA7C;;AACA,MAAIW,WAAW,IAAI,IAAnB,EAAyB;AACrB,UAAM,IAAIE,KAAJ,CAAU,qDAAV,CAAN;AACH;;AAED,QAAMC,cAAc,GAAG,QAAvB;AAEA;;;;;AAIA,QAAMZ,iBAAiB,GAAGD,OAAO,CAC5Bc,GADqB,CACjBJ,WADiB,EAErBK,UAFqB,CAEVJ,aAFU,aAEVA,aAFU,uBAEVA,aAAa,CAAGX,OAAO,CAACgB,GAAX,CAFH,EAGrBC,KAHqB,CAGf,CAACpB,QAAD,EAAWqB,WAAX,KAA2B;AAC9B;;;;;;;;;;AAUA,UAAMC,cAAc,GAAGD,WAAW,CAACrB,QAAD,CAAlC;AACAsB,IAAAA,cAAc,CAACxB,oBAAD,CAAd,GAAuCkB,cAAvC;AACA,WAAOM,cAAP;AACH,GAjBqB,EAkBrBjB,MAlBqB,CAkBdA,MAlBc,CAA1B;AAoBA,QAAMC,OAAO,GAAGF,iBAAiB,CAACG,KAAlC;AAEA,QAAMC,eAAe,GAAGJ,iBAAiB,CAACK,IAAlB,CAAwBC,GAAD,IAAS;AACpD;;;;;;;;;;;;;;;;;;;AAmBAA,IAAAA,GAAG,CAACZ,oBAAD,CAAH,GACIY,GAAG,CAACZ,oBAAD,CAAH,KAA8BkB,cADlC;AAEA,WAAON,GAAP;AACH,GAvBuB,CAAxB;AAyBA,QAAMC,iBAA6C,GAAIH,eAAvD;AACAG,EAAAA,iBAAiB,CAACJ,KAAlB,GAA0BD,OAA1B;AACA,SAAOK,iBAAP;AACH,CAjEM","sourcesContent":["// @flow\nimport type {Request, Response} from \"superagent\";\nimport type {RequestOptions, AbortablePromise} from \"./types.js\";\n\n/**\n * This is the name of the property we attach to responses so that we can\n * indicate if a response was from the cache or not.\n */\nexport const FROM_CACHE_PROP_NAME: string = \"_fromCache\";\n\n/**\n * Determine if a superagent response was from the cache or not.\n *\n * @param {SuperAgentResponse} response The response to check.\n * @returns {boolean} true if the response was from cache; otherwise false.\n */\nexport const isFromCache = (response: Response): boolean =>\n    response[FROM_CACHE_PROP_NAME] === true;\n\n/**\n * Turn unbuffered, uncached request into uncached request with or without\n * buffer.\n *\n * The request will resolve with an additional property to indicate if it was\n * resolved from cache or not.\n *\n * @param {RequestOptions} options Used to determine if the request should\n * buffer or not.\n * @param {Request} request The request to be modified.\n * @returns {Promise<Response>} A superagent request supporting caching for the\n * given URL.\n */\nexport const asUncachedRequest = (\n    options: RequestOptions,\n    request: Request,\n): AbortablePromise<Response> => {\n    /**\n     * We need to ensure that what we return has the `abort` method still so\n     * that we can let things like JSDOM call abort on promises.\n     */\n    const superagentRequest = request.buffer(options.buffer);\n    const abortFn = superagentRequest.abort;\n    const responsePromise = superagentRequest.then((res) => {\n        /**\n         * There's no cache, so this is definitely not from cache.\n         */\n        res[FROM_CACHE_PROP_NAME] = false;\n        return res;\n    });\n\n    const abortableResponse: AbortablePromise<Response> = (responsePromise: any);\n    abortableResponse.abort = abortFn;\n    return abortableResponse;\n};\n\n/**\n * Turn unbuffered, uncached request into cached request with or without buffer.\n *\n * Could resolve from cache if caching is enabled and the request has already\n * been fulfilled once. Otherwise, this creates a new request for the URL.\n *\n * The request will resolve with an additional property to indicate if it was\n * resolved from cache or not.\n *\n * @param {RequestOptions} options Used to determine caching setup and whether\n * the request should be buffered or not.\n * @param {Request} request The request to be modified.\n * @returns {Promise<Response>} A superagent request supporting caching for the\n * given URL.\n */\nexport const asCachedRequest = (\n    options: RequestOptions,\n    request: Request,\n): AbortablePromise<Response> => {\n    const {cachePlugin, getExpiration, buffer} = options;\n    if (cachePlugin == null) {\n        throw new Error(\"Cannot cache request without cache plugin instance.\");\n    }\n\n    const FRESHLY_PRUNED = \"PRUNED\";\n\n    /**\n     * We need to ensure that what we return has the `abort` method still so\n     * that we can let things like JSDOM call abort on promises.\n     */\n    const superagentRequest = request\n        .use(cachePlugin)\n        .expiration(getExpiration?.(request.url))\n        .prune((response, gutResponse) => {\n            /**\n             * This is called to prune a response before it goes into the\n             * cache.\n             *\n             * We want to use our own `prune` method so that we can track\n             * what comes from cache versus what doesn't.\n             *\n             * But we still do the same thing that superagent-cache would\n             * do, for now.\n             */\n            const guttedResponse = gutResponse(response);\n            guttedResponse[FROM_CACHE_PROP_NAME] = FRESHLY_PRUNED;\n            return guttedResponse;\n        })\n        .buffer(buffer);\n\n    const abortFn = superagentRequest.abort;\n\n    const responsePromise = superagentRequest.then((res) => {\n        /**\n         * Set the FROM_CACHE_PROP_NAME property to a boolean value.\n         *\n         * This works because if it is a brand new response that was just\n         * cached, then the FROM_CACHE_PROP_NAME property is set explicitly\n         * to FRESHLY_PRUNED. Therefore, we know it was not\n         * previously cached. So, we set FROM_CACHE_PROP_NAME property to\n         * false.\n         *\n         * The response we get here is what is in the cache so any\n         * modifications we make are reflected in the cached value.\n         *\n         * That means that if we get here and the FROM_CACHE_PROP_NAME is\n         * not equal to FRESHLY_PRUNED, it MUST have come from the\n         * cache and not a brand new request, so we can set the\n         * FROM_CACHE_PROP_NAME property to true!\n         *\n         * Cheeky, but it works ðŸ˜ˆ\n         */\n        res[FROM_CACHE_PROP_NAME] =\n            res[FROM_CACHE_PROP_NAME] !== FRESHLY_PRUNED;\n        return res;\n    });\n\n    const abortableResponse: AbortablePromise<Response> = (responsePromise: any);\n    abortableResponse.abort = abortFn;\n    return abortableResponse;\n};\n"],"file":"requests-from-cache.js"}