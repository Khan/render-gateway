{"version":3,"sources":["../src/requests-from-cache.js"],"names":["FROM_CACHE_PROP_NAME","isFromCache","response","asUncachedRequest","request","buffer","then","res","asCachedRequest","strategy","provider","getExpiration","superagentCache","FRESHLY_PRUNED","use","expiration","url","prune","gutResponse","guttedResponse"],"mappings":";;;;;;;AACA;;;;AAOA;;;;AAIO,MAAMA,oBAA4B,GAAG,YAArC;AAEP;;;;;;;;;AAMO,MAAMC,WAAW,GAAIC,QAAD,IACvBA,QAAQ,CAACF,oBAAD,CAAR,KAAmC,IADhC;AAGP;;;;;;;;;;;;;;;;;AAaO,MAAMG,iBAAiB,GAAG,CAC7BC,OAD6B,EAE7BC,MAF6B,KAI7BD,OAAO,CAACC,MAAR,CAAeA,MAAf,EAAuBC,IAAvB,CAA6BC,GAAD,IAAS;AACjC;;;AAGAA,EAAAA,GAAG,CAACP,oBAAD,CAAH,GAA4B,KAA5B;AACA,SAAOO,GAAP;AACH,CAND,CAJG;AAYP;;;;;;;;;;;;;;;;;;;;AAgBO,MAAMC,eAAe,GAAG,CAC3BJ,OAD2B,EAE3BK,QAF2B,EAG3BJ,MAH2B,KAIP;AACpB,QAAM;AAACK,IAAAA,QAAD;AAAWC,IAAAA;AAAX,MAA4BF,QAAlC;AAEA,QAAMG,eAAe,GAAG,oCAAsBF,QAAtB,CAAxB;AACA,QAAMG,cAAc,GAAG,QAAvB;AAEA,SAAOT,OAAO,CACTU,GADE,CACEF,eADF,EAEFG,UAFE,CAESJ,aAFT,aAESA,aAFT,uBAESA,aAAa,CAAGP,OAAO,CAACY,GAAX,CAFtB,EAGFC,KAHE,CAGI,CAACf,QAAD,EAAWgB,WAAX,KAA2B;AAC9B;;;;;;;;;;AAUA,UAAMC,cAAc,GAAGD,WAAW,CAAChB,QAAD,CAAlC;AACAiB,IAAAA,cAAc,CAACnB,oBAAD,CAAd,GAAuCa,cAAvC;AACA,WAAOM,cAAP;AACH,GAjBE,EAkBFd,MAlBE,CAkBKA,MAlBL,EAmBFC,IAnBE,CAmBIC,GAAD,IAAS;AACX;;;;;;;;;;;;;;;;;;;AAmBAA,IAAAA,GAAG,CAACP,oBAAD,CAAH,GACIO,GAAG,CAACP,oBAAD,CAAH,KAA8Ba,cADlC;AAEA,WAAON,GAAP;AACH,GA1CE,CAAP;AA2CH,CArDM","sourcesContent":["// @flow\nimport superagentCachePlugin from \"superagent-cache-plugin\";\nimport type {\n    SuperAgentRequest,\n    Response as SuperAgentResponse,\n} from \"superagent\";\nimport type {CachingStrategy} from \"./types.js\";\n\n/**\n * This is the name of the property we attach to responses so that we can\n * indicate if a response was from the cache or not.\n */\nexport const FROM_CACHE_PROP_NAME: string = \"_fromCache\";\n\n/**\n * Determine if a superagent response was from the cache or not.\n *\n * @param {SuperAgentResponse} response The response to check.\n * @returns {boolean} true if the response was from cache; otherwise false.\n */\nexport const isFromCache = (response: SuperAgentResponse): boolean =>\n    response[FROM_CACHE_PROP_NAME] === true;\n\n/**\n * Turn unbuffered, uncached request into uncached request with or without\n * buffer.\n *\n * The request will resolve with an additional property to indicate if it was\n * resolved from cache or not.\n *\n * @param {SuperAgentRequest} request The request to be modified.\n * @param {boolean} buffer When true, the response body will be buffered,\n * otherwise it will not.\n * @returns {SuperAgentRequest} A superagent request supporting caching for the\n * given URL.\n */\nexport const asUncachedRequest = (\n    request: SuperAgentRequest,\n    buffer: boolean,\n): SuperAgentRequest =>\n    request.buffer(buffer).then((res) => {\n        /**\n         * There's no cache, so this is definitely not from cache.\n         */\n        res[FROM_CACHE_PROP_NAME] = false;\n        return res;\n    });\n\n/**\n * Turn unbuffered, uncached request into cached request with or without buffer.\n *\n * Could resolve from cache if caching is enabled and the request has already\n * been fulfilled once. Otherwise, this creates a new request for the URL.\n *\n * The request will resolve with an additional property to indicate if it was\n * resolved from cache or not.\n *\n * @param {SuperAgentRequest} request The request to be modified.\n * @param {CachingStrategy} strategy The strategy to control caching.\n * @param {boolean} buffer When true, the response body will be buffered,\n * otherwise it will not.\n * @returns {SuperAgentRequest} A superagent request supporting caching for the\n * given URL.\n */\nexport const asCachedRequest = (\n    request: SuperAgentRequest,\n    strategy: CachingStrategy,\n    buffer: boolean,\n): SuperAgentRequest => {\n    const {provider, getExpiration} = strategy;\n\n    const superagentCache = superagentCachePlugin(provider);\n    const FRESHLY_PRUNED = \"PRUNED\";\n\n    return request\n        .use(superagentCache)\n        .expiration(getExpiration?.(request.url))\n        .prune((response, gutResponse) => {\n            /**\n             * This is called to prune a response before it goes into the\n             * cache.\n             *\n             * We want to use our own `prune` method so that we can track\n             * what comes from cache versus what doesn't.\n             *\n             * But we still do the same thing that superagent-cache would\n             * do, for now.\n             */\n            const guttedResponse = gutResponse(response);\n            guttedResponse[FROM_CACHE_PROP_NAME] = FRESHLY_PRUNED;\n            return guttedResponse;\n        })\n        .buffer(buffer)\n        .then((res) => {\n            /**\n             * Set the FROM_CACHE_PROP_NAME property to a boolean value.\n             *\n             * This works because if it is a brand new response that was just\n             * cached, then the FROM_CACHE_PROP_NAME property is set explicitly\n             * to FRESHLY_PRUNED. Therefore, we know it was not\n             * previously cached. So, we set FROM_CACHE_PROP_NAME property to\n             * false.\n             *\n             * The response we get here is what is in the cache so any\n             * modifications we make are reflected in the cached value.\n             *\n             * That means that if we get here and the FROM_CACHE_PROP_NAME is\n             * not equal to FRESHLY_PRUNED, it MUST have come from the\n             * cache and not a brand new request, so we can set the\n             * FROM_CACHE_PROP_NAME property to true!\n             *\n             * Cheeky, but it works ðŸ˜ˆ\n             */\n            res[FROM_CACHE_PROP_NAME] =\n                res[FROM_CACHE_PROP_NAME] !== FRESHLY_PRUNED;\n            return res;\n        });\n};\n"],"file":"requests-from-cache.js"}