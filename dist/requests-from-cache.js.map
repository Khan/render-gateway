{"version":3,"sources":["../src/requests-from-cache.js"],"names":["FROM_CACHE_PROP_NAME","isFromCache","response","asUncachedRequest","options","request","buffer","then","res","asCachedRequest","cachePlugin","getExpiration","Error","FRESHLY_PRUNED","use","expiration","url","prune","gutResponse","guttedResponse"],"mappings":";;;;;;;AAIA;;;;AAIO,MAAMA,oBAA4B,GAAG,YAArC;AAEP;;;;;;;;;AAMO,MAAMC,WAAW,GAAIC,QAAD,IACvBA,QAAQ,CAACF,oBAAD,CAAR,KAAmC,IADhC;AAGP;;;;;;;;;;;;;;;;;AAaO,MAAMG,iBAAiB,GAAG,CAC7BC,OAD6B,EAE7BC,OAF6B,KAI7BA,OAAO,CAACC,MAAR,CAAeF,OAAO,CAACE,MAAvB,EAA+BC,IAA/B,CAAqCC,GAAD,IAAS;AACzC;;;AAGAA,EAAAA,GAAG,CAACR,oBAAD,CAAH,GAA4B,KAA5B;AACA,SAAOQ,GAAP;AACH,CAND,CAJG;AAYP;;;;;;;;;;;;;;;;;;;AAeO,MAAMC,eAAe,GAAG,CAC3BL,OAD2B,EAE3BC,OAF2B,KAGP;AACpB,QAAM;AAACK,IAAAA,WAAD;AAAcC,IAAAA,aAAd;AAA6BL,IAAAA;AAA7B,MAAuCF,OAA7C;;AACA,MAAIM,WAAW,IAAI,IAAnB,EAAyB;AACrB,UAAM,IAAIE,KAAJ,CAAU,qDAAV,CAAN;AACH;;AAED,QAAMC,cAAc,GAAG,QAAvB;AAEA,SAAOR,OAAO,CACTS,GADE,CACEJ,WADF,EAEFK,UAFE,CAESJ,aAFT,aAESA,aAFT,uBAESA,aAAa,CAAGN,OAAO,CAACW,GAAX,CAFtB,EAGFC,KAHE,CAGI,CAACf,QAAD,EAAWgB,WAAX,KAA2B;AAC9B;;;;;;;;;;AAUA,UAAMC,cAAc,GAAGD,WAAW,CAAChB,QAAD,CAAlC;AACAiB,IAAAA,cAAc,CAACnB,oBAAD,CAAd,GAAuCa,cAAvC;AACA,WAAOM,cAAP;AACH,GAjBE,EAkBFb,MAlBE,CAkBKA,MAlBL,EAmBFC,IAnBE,CAmBIC,GAAD,IAAS;AACX;;;;;;;;;;;;;;;;;;;AAmBAA,IAAAA,GAAG,CAACR,oBAAD,CAAH,GACIQ,GAAG,CAACR,oBAAD,CAAH,KAA8Ba,cADlC;AAEA,WAAOL,GAAP;AACH,GA1CE,CAAP;AA2CH,CAtDM","sourcesContent":["// @flow\nimport type {Request, Response} from \"superagent\";\nimport type {RequestOptions} from \"./types.js\";\n\n/**\n * This is the name of the property we attach to responses so that we can\n * indicate if a response was from the cache or not.\n */\nexport const FROM_CACHE_PROP_NAME: string = \"_fromCache\";\n\n/**\n * Determine if a superagent response was from the cache or not.\n *\n * @param {SuperAgentResponse} response The response to check.\n * @returns {boolean} true if the response was from cache; otherwise false.\n */\nexport const isFromCache = (response: Response): boolean =>\n    response[FROM_CACHE_PROP_NAME] === true;\n\n/**\n * Turn unbuffered, uncached request into uncached request with or without\n * buffer.\n *\n * The request will resolve with an additional property to indicate if it was\n * resolved from cache or not.\n *\n * @param {RequestOptions} options Used to determine if the request should\n * buffer or not.\n * @param {Request} request The request to be modified.\n * @returns {Promise<Response>} A superagent request supporting caching for the\n * given URL.\n */\nexport const asUncachedRequest = (\n    options: RequestOptions,\n    request: Request,\n): Promise<Response> =>\n    request.buffer(options.buffer).then((res) => {\n        /**\n         * There's no cache, so this is definitely not from cache.\n         */\n        res[FROM_CACHE_PROP_NAME] = false;\n        return res;\n    });\n\n/**\n * Turn unbuffered, uncached request into cached request with or without buffer.\n *\n * Could resolve from cache if caching is enabled and the request has already\n * been fulfilled once. Otherwise, this creates a new request for the URL.\n *\n * The request will resolve with an additional property to indicate if it was\n * resolved from cache or not.\n *\n * @param {RequestOptions} options Used to determine caching setup and whether\n * the request should be buffered or not.\n * @param {Request} request The request to be modified.\n * @returns {Promise<Response>} A superagent request supporting caching for the\n * given URL.\n */\nexport const asCachedRequest = (\n    options: RequestOptions,\n    request: Request,\n): Promise<Response> => {\n    const {cachePlugin, getExpiration, buffer} = options;\n    if (cachePlugin == null) {\n        throw new Error(\"Cannot cache request without cache plugin instance.\");\n    }\n\n    const FRESHLY_PRUNED = \"PRUNED\";\n\n    return request\n        .use(cachePlugin)\n        .expiration(getExpiration?.(request.url))\n        .prune((response, gutResponse) => {\n            /**\n             * This is called to prune a response before it goes into the\n             * cache.\n             *\n             * We want to use our own `prune` method so that we can track\n             * what comes from cache versus what doesn't.\n             *\n             * But we still do the same thing that superagent-cache would\n             * do, for now.\n             */\n            const guttedResponse = gutResponse(response);\n            guttedResponse[FROM_CACHE_PROP_NAME] = FRESHLY_PRUNED;\n            return guttedResponse;\n        })\n        .buffer(buffer)\n        .then((res) => {\n            /**\n             * Set the FROM_CACHE_PROP_NAME property to a boolean value.\n             *\n             * This works because if it is a brand new response that was just\n             * cached, then the FROM_CACHE_PROP_NAME property is set explicitly\n             * to FRESHLY_PRUNED. Therefore, we know it was not\n             * previously cached. So, we set FROM_CACHE_PROP_NAME property to\n             * false.\n             *\n             * The response we get here is what is in the cache so any\n             * modifications we make are reflected in the cached value.\n             *\n             * That means that if we get here and the FROM_CACHE_PROP_NAME is\n             * not equal to FRESHLY_PRUNED, it MUST have come from the\n             * cache and not a brand new request, so we can set the\n             * FROM_CACHE_PROP_NAME property to true!\n             *\n             * Cheeky, but it works ðŸ˜ˆ\n             */\n            res[FROM_CACHE_PROP_NAME] =\n                res[FROM_CACHE_PROP_NAME] !== FRESHLY_PRUNED;\n            return res;\n        });\n};\n"],"file":"requests-from-cache.js"}